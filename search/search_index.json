{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"PyCO2SYS","text":"<p>PyCO2SYS v2</p> <p>These are the docs for the forthcoming PyCO2SYS v2!</p> <p>These instructions will not work for the current version 1.8 that can be installed through pip and conda - please see PyCO2SYS.readthedocs.io for documentation for the latest release.</p> <p>If you are here to test PyCO2SYS v2, then create a test environment with Python v3.10 or greater, and then in that environment run</p> <pre><code>pip install git+https://github.com/mvdh7/PyCO2SYS@jax\n</code></pre> <p>This installs PyCO2SYS and its core requirements (JAX and NetworkX).  If you wish to try out using PyCO2SYS with pandas and/or xarray, you'll need to install those into the environment separately.</p> <p>PyCO2SYS is a Python toolbox for solving the marine carbonate system and calculating related seawater properties.  It was originally based on CO2SYS for MATLAB<sup>1</sup>.</p>"},{"location":"#installation","title":"Installation","text":"<p>Don't follow these instructions</p> <p>The installation instructions below are not yet active - see the box above if you're here to test PyCO2SYS!</p> <p>JAX double precision</p> <p>On import, PyCO2SYS should automatically set JAX in double precision mode.  However, it's possible that this won't always happen, which will adversely affect the results.  If a warning about this appears when running code, or to be on the safe side, set the environment variable <code>JAX_ENABLE_X64=True</code> to enforce this behaviour, for example:</p> <pre><code>conda env config vars set JAX_ENABLE_X64=True\n</code></pre>"},{"location":"#with-pip","title":"With pip","text":"<p>Install from the Python Package Index:</p> <pre><code>pip install PyCO2SYS\n</code></pre>"},{"location":"#with-condamamba","title":"With conda/mamba","text":"<p>Use pip on Windows</p> <p>PyCO2SYS v2 cannot currently be installed through conda on Windows \u2013 use pip instead.</p> <p>Install from the conda-forge channel:</p> <pre><code>conda install conda-forge::PyCO2SYS\n</code></pre>"},{"location":"#how-to-use-pyco2sys","title":"How to use PyCO2SYS","text":"<p>Start with the</p> <ul> <li>Quick-start guide</li> </ul> <p>before moving on to</p> <ul> <li>Arguments and results,</li> <li>Adjust conditions and</li> <li>Uncertainty propagation.</li> </ul> <p>If you're really interested, also look at</p> <ul> <li>Advanced results access.</li> </ul> <p>If you're already familiar with PyCO2SYS v1, then</p> <ul> <li>Switching from v1 to v2</li> </ul> <p>may help you to transition.</p>"},{"location":"#examples","title":"Examples","text":"<p>You can see some working examples of PyCO2SYS in action on Github at PyCO2SYS-examples.  You can run all of the notebooks there live in your browser via Binder, without installing anything on your computer.</p> <p>Adding your notebooks showcasing PyCO2SYS to PyCO2SYS-examples is welcomed!</p>"},{"location":"#about","title":"About","text":"<p>PyCO2SYS is maintained primarily by Dr Matthew Humphreys of NIOZ Royal Netherlands Institute for Sea Research (Texel) with support from the main developers of all previous versions of CO2SYS.</p>"},{"location":"#citation","title":"Citation","text":"<p>A paper describing PyCO2SYS is freely available:</p> <p>PyCO2SYS manuscript</p> <p>Humphreys, M. P., Lewis, E. R., Sharp, J. D., and Pierrot, D. (2022).  PyCO2SYS v1.8: marine carbonate system calculations in Python.  Geoscientific Model Development 15, 15-43.  doi:10.5194/gmd-15-15-2022.</p> <p>To cite the PyCO2SYS software itself:</p> <p>PyCO2SYS code citation</p> <p>Humphreys, M. P., Schiller, A. J., Sandborn, D. E., Gregor, L., Pierrot, D., van Heuven, S. M. A. C., Lewis, E. R., and Wallace, D. W. R. (2024).  PyCO2SYS: marine carbonate system calculations in Python.  Zenodo. doi:10.5281/zenodo.3744275.</p> <p>The DOI above refers to all versions of PyCO2SYS.  Please specify which version of PyCO2SYS you used.  You can find the version number that you are using in Python with:</p> <pre><code>import PyCO2SYS as pyco2\npyco2.hello()\n</code></pre> <p>You should also consider citing the original work by Lewis and Wallace (1998), and specify which optional sets of constants you used in your calculations.</p>"},{"location":"#history","title":"History","text":"<p>The original CO2SYS program for DOS was created by Ernie Lewis and Doug Wallace (LW98).  This was translated into MATLAB by Denis Pierrot and subsequently optimised by Steven van Heuven (HPR11).  Jim Orr and co-authors added further sets of equilibrium constants and implemented error propagation in a separate program (OEDG18).  The latest MATLAB version was translated into Python as PyCO2SYS by Matthew Humphreys, benefitting enormously from all this previous work.  Further (ongoing) modifications and additions to the PyCO2SYS code and documentation have been made by Matthew Humphreys, Luke Gregor, Daniel Sandborn and Abigail Schiller (HSS21).</p>"},{"location":"#license","title":"License","text":"<p>PyCO2SYS is licensed under the GNU General Public License version 3 (GPLv3).</p>"},{"location":"#contributing","title":"Contributing","text":"<p>Suggestions for new features, bug reports and contributions to PyCO2SYS are very welcome.  Please follow the contributing guidelines.</p> <p>To add a notebook to PyCO2SYS-examples, please follow the contributing guidelines of that repo.</p> <ol> <li> <p>For CO2SYS for MATLAB refer to LW98, HPR11 and OEDG18.\u00a0\u21a9</p> </li> </ol>"},{"location":"adjust/","title":"Adjust conditions","text":"<p>To adjust the system to a different set of temperature and/or pressure conditions, use <code>adjust</code>:</p> <pre><code>co2s_adj = co2s.adjust(\n    temperature=25,\n    pressure=1000,\n    store_steps=1,\n    method_fCO2=1,\n    opt_which_fCO2_insitu=1,\n    bh_upsilon=None,\n)\n</code></pre> <p>The result <code>co2s_adj</code> is a new <code>CO2System</code> with all values at the new conditions (above, temperature of 25 \u00b0C and hydrostatic pressure of 1000 dbar).</p> <p>For more on the <code>store_steps</code> kwarg, see Advanced results access.</p> <p>The <code>adjust</code> method can be used if any two carbonate system parameters are known, but also if only one of pCO<sub>2</sub>, fCO<sub>2</sub>, [CO<sub>2</sub>(aq)] or xCO<sub>2</sub> is known.  In this case, <code>adjust</code> can take additional kwargs:</p> <ul> <li> <p><code>method_fCO2</code>: how to do the temperature conversion.</p> <ul> <li><code>1</code>: using the parameterised \u03c5<sub>h</sub> equation of H24 (default). </li> <li><code>2</code>: using the constant \u03c5<sub>h</sub> fitted to the TOG93 dataset by H24.</li> <li><code>3</code>: using the constant theoretical \u03c5<sub>x</sub> of H24.</li> <li><code>4</code>: following the H24 approach but using a user-provided b_h value (given with the additional kwarg <code>bh_upsilon</code>).</li> <li><code>5</code>: using the linear fit of TOG93.</li> <li><code>6</code>: using the quadratic fit of TOG93 (default before v1.8.3).</li> </ul> </li> <li> <p><code>opt_which_fCO2_insitu</code>: whether the input (<code>1</code>, default) or output (<code>2</code>) condition pCO<sub>2</sub>, fCO<sub>2</sub>, [CO<sub>2</sub>(aq)] and/or xCO<sub>2</sub> values are at in situ conditions, for determining b_h with the parameterisation of H24.  Only applies when <code>method_fCO2</code> is <code>1</code>.</p> </li> <li> <p><code>bh_upsilon</code>: If this is a single-parameter system and <code>method_fCO2</code> is <code>4</code>, then the value of b_h in J/mol must be specified here.</p> </li> </ul>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#PyCO2SYS--pyco2sys","title":"PyCO2SYS","text":"<p>Marine carbonate system calculations in Python.</p>"},{"location":"api/#PyCO2SYS.CO2System","title":"<code>CO2System</code>","text":"<p>               Bases: <code>UserDict</code></p> Source code in <code>PyCO2SYS/engine.py</code> <pre><code>class CO2System(UserDict):\n    def __init__(self, pd_index=None, xr_dims=None, xr_shape=None, **kwargs):\n        super().__init__()\n        opts = {k: v for k, v in kwargs.items() if k.startswith(\"opt_\")}\n        data = {k: v for k, v in kwargs.items() if k not in opts}\n        # Get icase\n        core_known = np.array([v in data for v in parameters_core])\n        icase_all = np.arange(1, len(parameters_core) + 1)\n        icase = icase_all[core_known]\n        assert len(icase) &lt; 3, \"A maximum of 2 known core parameters can be provided.\"\n        if len(icase) == 0:\n            icase = np.array(0)\n        elif len(icase) == 2:\n            icase = icase[0] * 100 + icase[1]\n        self.icase = icase.item()\n        self.opts = opts_default.copy()\n        # Assign opts\n        for k, v in opts.items():\n            if k in get_funcs_opts:\n                assert np.isscalar(v)\n                assert v in get_funcs_opts[k].keys(), (\n                    \"{} is not allowed for {}!\".format(v, k)\n                )\n            else:\n                warnings.warn(\n                    \"'{}' is not recognised\".format(k)\n                    + \" - it will not be used in any calculations.\"\n                )\n        self.opts.update(opts)\n        # Deal with tricky special cases\n        if self.icase != 207:\n            self.opts.pop(\"opt_HCO3_root\")\n        if self.icase not in [0, 4, 5, 8, 9]:\n            self.opts.pop(\"opt_fCO2_temperature\")\n        # Assemble graphs and computation functions\n        self.graph, self.funcs, self.data = self._assemble(self.icase, data)\n        for k in self.data:\n            if k not in self.graph.nodes:\n                warnings.warn(\n                    \"'{}' is not recognised\".format(k)\n                    + \" - it will not be used in any calculations.\"\n                )\n        self.grads = {}\n        self.uncertainty = {}\n        self.requested = set()  # keep track of all parameters that have been requested\n        self.pd_index = pd_index\n        if xr_dims is not None:\n            assert xr_shape is not None\n            assert len(xr_dims) == len(xr_shape)\n        else:\n            assert xr_shape is None\n        self.xr_dims = xr_dims\n        self.xr_shape = xr_shape\n\n    def __getitem__(self, key):\n        # When the user requests a dict key that hasn't been solved for yet, then solve\n        # and provide the requested parameter\n        self.solve(parameters=key)\n        if isinstance(key, list):\n            # If the user provides a list of keys to solve for, return all of them as\n            # a dict\n            return {k: self.data[k] for k in key}\n        else:\n            # If a single key is requested, return the corresponding value(s) directly\n            return self.data[key]\n\n    def __getattr__(self, attr):\n        # This allows solved parameter values to be accessed with dot notation, purely\n        # for convenience.\n        # So, when the user tries to access something with dot notation...\n        try:\n            # ... then if it's an attribute, return it (this is the standard behaviour).\n            return object.__getattribute__(self, attr)\n        except AttributeError:\n            # But if it's not an attribute...\n            try:\n                # ... return the corresponding parameter value, if it's already been\n                # solved for...\n                return self.data[attr]\n            except KeyError:\n                # ... but it if hasn't been solved for, throw an error.  The user needs\n                # to use the normal dict notation (or solve method) to solve for it.\n                raise AttributeError(attr)\n\n    def __setitem__(self, key, value):\n        # Don't allow the user to assign new key-value pairs to the dict\n        raise RuntimeError(\"Item assignment is not supported.\")\n\n    def _assemble(self, icase, data):\n        # Deal with tricky special cases\n        if icase == 207:\n            graph_opts = get_graph_opts()\n        else:\n            graph_opts = get_graph_opts(exclude=\"opt_HCO3_root\")\n        # Assemble graph and functions\n        graph = nx.compose(graph_fixed, graph_core[icase])\n        funcs = get_funcs.copy()\n        funcs.update(get_funcs_core[icase])\n        for opt, v in self.opts.items():\n            graph = nx.compose(graph, graph_opts[opt][v])\n            funcs.update(get_funcs_opts[opt][v])\n        # Assign default values\n        data = data.copy()\n        for k, v in values_default.items():\n            if k not in data:\n                data[k] = v\n                graph.add_node(k)\n        # Save arguments\n        for k, v in data.items():\n            if v is not None:\n                # state 1 means that the value was provided as an argument\n                nx.set_node_attributes(graph, {k: 1}, name=\"state\")\n        self.nodes_original = list(k for k, v in data.items() if v is not None)\n        return graph, funcs, data\n\n    def solve(self, parameters=None, store_steps=1):\n        \"\"\"Calculate parameter(s) and store them internally.\n\n        Parameters\n        ----------\n        parameters : str or list of str, optional\n            Which parameter(s) to calculate and store, by default None, in which case\n            all possible parameters are calculated and stored internally.\n        store_steps : int, optional\n            Whether/which non-requested parameters calculated during intermediate\n            calculation steps should be stored, by default 1.  The options are\n                0 - store only the specifically requested parameters,\n                1 - store the most used set of intermediate parameters, or\n                2 - store the complete set of parameters.\n        \"\"\"\n        # Parse user-provided parameters (if there are any)\n        if parameters is None:\n            # If no parameters are provided, then we solve for everything possible\n            parameters = list(self.graph.nodes)\n        elif isinstance(parameters, str):\n            # Allow user to provide a string if only one parameter is desired\n            parameters = [parameters]\n        parameters = set(parameters)  # get rid of duplicates\n        self.requested |= parameters\n        self_data = self.data.copy()  # what was already known before this solve\n        # Remove known nodes from a copy of self.graph, so that ancestors of known nodes\n        # are not unnecessarily recomputed\n        graph_unknown = self.graph.copy()\n        graph_unknown.remove_nodes_from([k for k in self_data if k not in parameters])\n        # Add intermediate parameters that we need to know in order to calculate the\n        # requested parameters\n        parameters_all = parameters.copy()\n        for p in parameters:\n            parameters_all = parameters_all | nx.ancestors(graph_unknown, p)\n        # Convert the set of parameters into a list, exclude already-known ones, and\n        # organise the list into the order required for calculations\n        parameters_all = [\n            p\n            for p in nx.topological_sort(self.graph)\n            if p in parameters_all and p not in self_data\n        ]\n        store_parameters = []\n        for p in parameters_all:\n            priors = self.graph.pred[p]\n            if len(priors) == 0 or all([r in self_data for r in priors]):\n                self_data[p] = self.funcs[p](\n                    *[\n                        self_data[r]\n                        for r in self.funcs[p].__code__.co_varnames[\n                            : self.funcs[p].__code__.co_argcount\n                        ]\n                    ]\n                )\n                store_here = (\n                    #  If store_steps is 0, store only requested parameters\n                    (store_steps == 0 and p in parameters)\n                    | (\n                        # If store_steps is 1, store all but the equilibrium constants\n                        # on the seawater scale, at 1 atm and their pressure-correction\n                        # factors, and a few selected others\n                        store_steps == 1\n                        and not p.startswith(\"factor_k_\")\n                        and not (p.startswith(\"k_\") and p.endswith(\"_sws\"))\n                        and not p.endswith(\"_1atm\")\n                        and p not in [\"sws_to_opt\", \"opt_to_free\", \"ionic_strength\"]\n                    )\n                    |  # If store_steps is 2, store everything\n                    (store_steps == 2)\n                )\n                if store_here:\n                    store_parameters.append(p)\n                    # state = 2 means that the value was calculated internally\n                    nx.set_node_attributes(self.graph, {p: 2}, name=\"state\")\n                    for f in self.funcs[p].__code__.co_varnames[\n                        : self.funcs[p].__code__.co_argcount\n                    ]:\n                        nx.set_edge_attributes(self.graph, {(f, p): 2}, name=\"state\")\n        # Get rid of jax overhead on results\n        self_data = {k: v for k, v in self_data.items() if k in store_parameters}\n        _remove_jax_overhead(self_data)\n        self.data.update(self_data)\n\n    def to_pandas(self, parameters=None, store_steps=1):\n        \"\"\"Return parameters as a pandas `Series` or `DataFrame`.  All parameters should\n        be scalar or one-dimensional vectors of the same size.\n\n        Parameters\n        ----------\n        parameters : str or list of str, optional\n            The parameter(s) to return.  These are solved for if not already available.\n            If `None`, then all parameters that have already been solved for are\n            returned.\n        store_steps : int, optional\n            See `solve`.\n\n        Returns\n        -------\n        pd.Series or pd.DataFrame\n            The parameter(s) as a `pd.Series` (if `parameters` is a `str`) or as a\n            `pd.DataFrame` (if `parameters` is a `list`) with the original pandas index\n            passed into the `CO2System` as `data`.  If `data` was not a `pd.DataFrame`\n            then the default index will be used.\n        \"\"\"\n        try:\n            import pandas as pd\n\n            if parameters is None:\n                parameters = self.keys()\n            self.solve(parameters=parameters, store_steps=store_steps)\n            if isinstance(parameters, str):\n                return pd.Series(data=self[parameters], index=self.pd_index)\n            else:\n                return pd.DataFrame(\n                    {\n                        p: pd.Series(\n                            data=self[p] * np.ones(self.pd_index.shape),\n                            index=self.pd_index,\n                        )\n                        for p in parameters\n                    }\n                )\n        except ImportError:\n            warnings.warn(\"pandas could not be imported.\")\n\n    def _get_xr_ndims(self, parameter):\n        ndims = []\n        if not np.isscalar(self[parameter]):\n            for i, vs in enumerate(self[parameter].shape):\n                if vs == self.xr_shape[i]:\n                    ndims.append(self.xr_dims[i])\n        return ndims\n\n    def to_xarray(self, parameters=None, store_steps=1):\n        \"\"\"Return parameters as an xarray `DataArray` or `Dataset`.\n\n        Parameters\n        ----------\n        parameters : str or list of str, optional\n            The parameter(s) to return.  These are solved for if not already available.\n            If `None`, then all parameters that have already been solved for are\n            returned.\n        store_steps : int, optional\n            See `solve`.\n\n        Returns\n        -------\n        xr.DataArray or xr.Dataset\n            The parameter(s) as a `xr.DataArray` (if `parameters` is a `str`) or as a\n            `xr.Dataset` (if `parameters` is a `list`) with the original xarray\n            dimensions passed into the `CO2System` as `data`.  If `data` was not an\n            `xr.Dataset` then this function will not work.\n        \"\"\"\n        assert self.xr_dims is not None and self.xr_shape is not None, (\n            \"`data` was not provided as an `xr.Dataset` \"\n            + \"when creating this `CO2System`.\"\n        )\n        try:\n            import xarray as xr\n\n            if parameters is None:\n                parameters = self.keys()\n            self.solve(parameters=parameters, store_steps=store_steps)\n            if isinstance(parameters, str):\n                ndims = self._get_xr_ndims(parameters)\n                return xr.DataArray(np.squeeze(self[parameters]), dims=ndims)\n            else:\n                return xr.Dataset(\n                    {\n                        p: xr.DataArray(np.squeeze(self[p]), dims=self._get_xr_ndims(p))\n                        for p in parameters\n                    }\n                )\n        except ImportError:\n            warnings.warn(\"xarray could not be imported.\")\n\n    def _get_expUps(\n        self,\n        method_fCO2,\n        temperature,\n        bh_upsilon=None,\n        opt_which_fCO2_insitu=1,\n    ):\n        if method_fCO2 in [1, 2, 3, 4]:\n            self.solve(\"gas_constant\")\n        match method_fCO2:\n            case 1:\n                self.solve(\"fCO2\", store_steps=0)\n                fCO2 = self.fCO2\n                assert opt_which_fCO2_insitu in [1, 2]\n                if opt_which_fCO2_insitu == 2:\n                    # If the output conditions are the environmental ones, then we need\n                    # to provide an estimate of output fCO2 in order to use the bh\n                    # parameterisation; we get this using the method_fCO2=2 approach:\n                    fCO2 = fCO2 * upsilon.expUps_TOG93_H24(\n                        self.data[\"temperature\"],\n                        temperature,\n                        self.data[\"gas_constant\"],\n                    )\n                return upsilon.expUps_parameterised_H24(\n                    self.data[\"temperature\"],\n                    temperature,\n                    self.data[\"salinity\"],\n                    fCO2,\n                    self.data[\"gas_constant\"],\n                    opt_which_fCO2_insitu=opt_which_fCO2_insitu,\n                )\n            case 2:\n                return upsilon.expUps_TOG93_H24(\n                    self.data[\"temperature\"],\n                    temperature,\n                    self.data[\"gas_constant\"],\n                )\n            case 3:\n                return upsilon.expUps_enthalpy_H24(\n                    self.data[\"temperature\"],\n                    temperature,\n                    self.data[\"gas_constant\"],\n                )\n            case 4:\n                assert bh_upsilon is not None, (\n                    \"A bh_upsilon value must be provided for method_fCO2=4.\"\n                )\n                return upsilon.expUps_Hoff_H24(\n                    self.data[\"temperature\"],\n                    temperature,\n                    self.data[\"gas_constant\"],\n                    bh_upsilon,\n                )\n            case 5:\n                return upsilon.expUps_linear_TOG93(\n                    self.data[\"temperature\"],\n                    temperature,\n                )\n            case 6:\n                return upsilon.expUps_quadratic_TOG93(\n                    self.data[\"temperature\"],\n                    temperature,\n                )\n\n    def adjust(\n        self,\n        temperature=None,\n        pressure=None,\n        store_steps=1,\n        method_fCO2=1,\n        opt_which_fCO2_insitu=1,\n        bh_upsilon=None,\n    ):\n        \"\"\"Adjust the system to a different temperature and/or pressure.\n\n        Parameters\n        ----------\n        temperature : float, optional\n            Temperature in \u00b0C to adjust to.  If `None`, temperature is not adjusted.\n        pressure : float, optional\n            Hydrostatic pressure in dbar to adjust to.  If `None`, pressure is not\n            adjusted.\n        store_steps : int, optional\n            Whether/which non-requested parameters calculated during intermediate\n            calculation steps should be stored.  The options are:\n\n              - `0`: Store only the requested parameters.\n              - `1`: Store the requested and most commonly used set of intermediate\n              parameters (default).\n              - `2`: Store the requested and complete set of intermediate parameters.\n        method_fCO2 : int, optional\n            If this is a single-parameter system, which method to use for the\n            adjustment.  The options are:\n\n              - `1`: parameterisation of H24 (default).\n              - `2`: constant bh fitted to TOG93 dataset by H24.\n              - `3`: constant theoretical bh of H24.\n              - `4`: user-specified bh with the equations of H24.\n              - `5`: linear fit of TOG93.\n              - `6`: quadratic fit of TOG93.\n        opt_which_fCO2_insitu : int, optional\n            If this is a single-parameter system and `method_fCO2` is `1`, whether:\n              - `1` the input condition (starting; default) or\n              - `2` output condition (adjusted) temperature\n            should be used to calculate $b_h$.\n        bh_upsilon : float, optional\n            If this is a single-parameter system and `method_fCO2` is `4`, then the\n            value of $b_h$ in J/mol must be specified here.\n\n        Returns\n        -------\n        CO2System\n            A new `CO2System` with all values adjusted to the requested temperature(s)\n            and/or pressure(s).\n        \"\"\"\n        if self.icase &gt; 100:\n            # If we know (any) two MCS parameters, solve for alkalinity and DIC under\n            # the \"input\" conditions\n            self.solve(parameters=[\"alkalinity\", \"dic\"], store_steps=store_steps)\n            core = {k: self[k] for k in [\"alkalinity\", \"dic\"]}\n            data = {}\n        elif self.icase in [4, 5, 8, 9]:\n            assert pressure is None, (\n                \"Cannot adjust pressure for a single-parameter system!\"\n            )\n            # If we know only one of pCO2, fCO2, xCO2 or CO2(aq), first get fCO2 under\n            # the \"input\" conditions\n            self.solve(parameters=\"fCO2\", store_steps=store_steps)\n            core = {\"fCO2\": self.fCO2}\n            # Then, convert this to the value at the new temperature using the requested\n            # method\n            assert method_fCO2 in range(1, 7), (\n                \"`method_fCO2` must be an integer from 1-6.\"\n            )\n            expUps = self._get_expUps(\n                method_fCO2,\n                temperature,\n                bh_upsilon=bh_upsilon,\n                opt_which_fCO2_insitu=opt_which_fCO2_insitu,\n            )\n            data = {\"fCO2\": core[\"fCO2\"] * expUps}\n        else:\n            warnings.warn(\n                \"Single-parameter temperature adjustments are possible only \"\n                + \"if the known parameter is one of pCO2, fCO2, xCO2 and CO2.\"\n            )\n        # Copy all parameters that are T/P independent into new data dict\n        for k in condition_independent:\n            if k in self.nodes_original:\n                data[k] = self.data[k]\n            elif k in core:\n                data[k] = core[k]\n        # Set temperature and/or pressure to adjusted value(s), unless they are None, in\n        # which case, don't adjust\n        if temperature is not None:\n            data[\"temperature\"] = temperature\n        else:\n            data[\"temperature\"] = self.data[\"temperature\"]\n        if pressure is not None:\n            data[\"pressure\"] = pressure\n        else:\n            data[\"pressure\"] = self.data[\"pressure\"]\n        sys = CO2System(\n            **data,\n            **self.opts,\n            pd_index=self.pd_index,\n            xr_dims=self.xr_dims,\n            xr_shape=self.xr_shape,\n        )\n        sys.solve(parameters=self.data)\n        return sys\n\n    def _get_func_of(self, var_of):\n        \"\"\"Create a function to compute ``var_of`` directly from an input set of values.\n\n        The created function has the signature\n\n            value_of = get_value_of(**value)\n\n        where the ``values`` are the originally user-defined values, obtained with\n        either of the following:\n\n            values_original = {k: sys.data[k] for k in sys.nodes_original}\n            values_original = sys.get_values_original()\n        \"\"\"\n        # We get a sub-graph of the node of interest and all its ancestors, excluding\n        # originally fixed / user-defined values\n        nodes_vo_all = nx.ancestors(self.graph, var_of)\n        nodes_vo_all.add(var_of)\n        # nodes_vo = onp.array([n for n in nodes_vo if n not in self.nodes_original])\n        nodes_vo = [n for n in nodes_vo_all if n not in self.nodes_original]\n        graph_vo = self.graph.subgraph(nodes_vo)\n\n        def get_value_of(**data):\n            data = data.copy()\n            # This loops through the functions in the correct order determined above so\n            # we end up calculating the value of interest, which is returned\n            for n in nx.topological_sort(graph_vo):\n                data.update(\n                    {\n                        n: self.funcs[n](\n                            *[\n                                data[v]\n                                for v in self.funcs[n].__code__.co_varnames[\n                                    : self.funcs[n].__code__.co_argcount\n                                ]\n                            ]\n                        )\n                    }\n                )\n            return data[var_of]\n\n        # Generate docstring\n        get_value_of.__doc__ = (\n            \"Calculate ``{}``.\".format(var_of)\n            + \"\\n\\nParameters\\n----------\"\n            + \"\\nvalues : dict\"\n            + \"\\n    Key-value pairs for the following parameters:\"\n        )\n        for p in nodes_vo_all:\n            if p in self.nodes_original:\n                get_value_of.__doc__ += \"\\n        {}\".format(p)\n        get_value_of.__doc__ += \"\\n\\nReturns\\n-------\"\n        get_value_of.__doc__ += \"\\n{}\".format(var_of)\n        return get_value_of\n\n    def _get_func_of_from_wrt(self, get_value_of, var_wrt):\n        \"\"\"Reorganise a function created with ``_get_func_of`` so that one of its kwargs\n        is instead a positional arg (and which can thus be gradded).\n\n        Parameters\n        ----------\n        get_value_of : func\n            Function created with ``_get_func_of``.\n        var_wrt : str\n            Name of the value to use as a positional arg instead.\n\n        Returns\n        -------\n        A function with the signature\n            value_of = get_of_from_wrt(value_wrt, **other_values_original)\n        \"\"\"\n\n        def get_value_of_from_wrt(value_wrt, **other_values_original):\n            other_values_original = other_values_original.copy()\n            other_values_original.update({var_wrt: value_wrt})\n            return get_value_of(**other_values_original)\n\n        return get_value_of_from_wrt\n\n    def get_grad_func(self, var_of, var_wrt):\n        get_value_of = self._get_func_of(var_of)\n        get_value_of_from_wrt = self._get_func_of_from_wrt(get_value_of, var_wrt)\n        return meta.egrad(get_value_of_from_wrt)\n\n    def get_grad(self, var_of, var_wrt):\n        \"\"\"Compute the derivative of `var_of` with respect to `var_wrt` and store it in\n        `sys.grads[var_of][var_wrt]`.  If there is already a value there, then that\n        value is returned instead of recalculating.\n\n        Parameters\n        ----------\n        var_of : str\n            The name of the variable to get the derivative of.\n        var_wrt : str\n            The name of the variable to get the derivative with respect to.  This must\n            be one of the fixed values provided when creating the `CO2System`, i.e.,\n            listed in its `nodes_original` attribute.\n        \"\"\"\n        assert var_wrt in self.nodes_original, (\n            \"`var_wrt` must be one of `sys.nodes_original!`\"\n        )\n        try:  # see if we've already calculated this value\n            d_of__d_wrt = self.grads[var_of][var_wrt]\n        except KeyError:  # only do the calculations if there isn't already a value\n            # We need to know the shape of the variable that we want the grad of, the\n            # easy way to get this is just to solve for it (if that hasn't already been\n            # done)\n            if var_of not in self.data:\n                self.solve(var_of)\n            # Next, we extract the originally set values, which are fixed during the\n            # differentiation\n            values_original = self.get_values_original()\n            other_values_original = values_original.copy()\n            # We have to make sure the value we are differentiating with respect to has\n            # the same shape as the value we want the differential of\n            value_wrt = other_values_original.pop(var_wrt) * np.ones_like(\n                self.data[var_of]\n            )\n            # Here we compute the gradient\n            grad_func = self.get_grad_func(var_of, var_wrt)\n            d_of__d_wrt = grad_func(value_wrt, **other_values_original)\n            # Put the final value into self.grads, first creating a new sub-dict if\n            # necessary\n            if var_of not in self.grads:\n                self.grads[var_of] = {}\n            self.grads[var_of][var_wrt] = d_of__d_wrt\n        return d_of__d_wrt\n\n    def get_grads(self, vars_of, vars_wrt):\n        \"\"\"Compute the derivatives of `vars_of` with respect to `vars_wrt` and store\n        them in `sys.grads[var_of][var_wrt]`.  If there are already values there, then\n        those values are returned instead of recalculating.\n\n        Parameters\n        ----------\n        vars_of : list\n            The names of the variables to get the derivatives of.\n        vars_wrt : list\n            The names of the variables to get the derivatives with respect to.  These\n            must all be one of the fixed values provided when creating the `CO2System`,\n            i.e., listed in its `nodes_original` attribute.\n        \"\"\"\n        if isinstance(vars_of, str):\n            vars_of = [vars_of]\n        if isinstance(vars_wrt, str):\n            vars_wrt = [vars_wrt]\n        for var_of, var_wrt in itertools.product(vars_of, vars_wrt):\n            self.get_grad(var_of, var_wrt)\n\n    def get_values_original(self):\n        return {k: self.data[k] for k in self.nodes_original}\n\n    def propagate(self, uncertainty_in, uncertainty_from):\n        \"\"\"Propagate independent uncertainties through the calculations.  Covariances\n        are not accounted for.\n\n        New entries are added in the `uncertainty` attribute, for example:\n\n            co2s = CO2System(dic=2100, alkalinity=2300)\n            co2s.propagate(\"pH\", {\"dic\": 2, \"alkalinity\": 2})\n            co2s.uncertainty[\"pH\"][\"total\"]  # total uncertainty in pH\n            co2s.uncertainty[\"pH\"][\"dic\"]  # component of ^ due to DIC uncertainty\n\n        Parameters\n        ----------\n        uncertainty_in : list\n            The parameters to calculate the uncertainty in.\n        uncertainty_from : dict\n            The parameters to propagate the uncertainty from (keys) and their\n            uncertainties (values).\n        \"\"\"\n        self.solve(uncertainty_in)\n        if isinstance(uncertainty_in, str):\n            uncertainty_in = [uncertainty_in]\n        for var_in in uncertainty_in:\n            # This should always be reset to zero and all values wiped, even if it\n            # already exists (so you don't end up with old uncertainty_from components\n            # from a previous calculation which are no longer part of the total)\n            self.uncertainty[var_in] = {\"total\": np.zeros_like(self.data[var_in])}\n            u_total = self.uncertainty[var_in][\"total\"]\n            for var_from, u_from in uncertainty_from.items():\n                is_pk = var_from.startswith(\"pk_\")\n                if is_pk:\n                    # If the uncertainty is given in terms of a pK value, we do the\n                    # calculations as if it were a K value, and convert at the end\n                    var_from = var_from[1:]\n                is_fractional = var_from.endswith(\"__f\")\n                if is_fractional:\n                    # If the uncertainty is fractional, multiply through by this\n                    var_from = var_from[:-3]\n                    u_from = self.data[var_from] * u_from\n                if var_from in self.nodes_original:\n                    self.get_grad(var_in, var_from)\n                    u_part = np.abs(self.grads[var_in][var_from] * u_from)\n                else:\n                    # If the uncertainty is from some internally calculated value, then\n                    # we need to make a second CO2System where that value is one of the\n                    # known inputs, and get the grad from that\n                    self.solve(var_from)\n                    data = self.get_values_original()\n                    data.update({var_from: self.data[var_from]})\n                    sys = CO2System(**data, **self.opts)\n                    sys.get_grad(var_in, var_from)\n                    u_part = np.abs(sys.grads[var_in][var_from] * u_from)\n                # Add the p back and convert value, if necessary\n                if is_pk:\n                    u_part = u_part * np.log(10) * np.abs(sys.data[var_from])\n                    var_from = \"p\" + var_from\n                if is_fractional:\n                    var_from += \"__f\"\n                self.uncertainty[var_in][var_from] = u_part\n                u_total = u_total + u_part**2\n            self.uncertainty[var_in][\"total\"] = np.sqrt(u_total)\n\n    def plot_graph(\n        self,\n        ax=None,\n        exclude_nodes=None,\n        prog_graphviz=\"neato\",\n        show_tsp=True,\n        show_unknown=True,\n        show_isolated=True,\n        skip_nodes=None,\n    ):\n        \"\"\"Draw a graph showing the relationships between the different parameters.\n\n        Parameters\n        ----------\n        ax : matplotlib axes, optional\n            The axes on which to plot.  If `None`, a new figure and axes are created.\n        exclude_nodes : list of str, optional\n            List of nodes to exclude from the plot, by default `None`.  Nodes in this\n            list are not shown, nor are connections to them or through them.\n        prog_graphviz : str, optional\n            Name of Graphviz layout program, by default \"neato\".\n        show_tsp : bool, optional\n            Whether to show temperature, salinity and pressure nodes, by default\n            `False`.\n        show_unknown : bool, optional\n            Whether to show nodes for parameters that have not (yet) been calculated,\n            by default `True`.\n        show_isolated : bool, optional\n            Whether to show nodes for parameters that are not connected to the graph,\n            by default `True`.\n        skip_nodes : bool, optional\n            List of nodes to skip from the plot, by default `None`.  Nodes in this list\n            are not shown, but the connections between their predecessors and children\n            are still drawn.\n\n        Returns\n        -------\n        matplotlib axes\n            The axes on which the graph is plotted.\n        \"\"\"\n        from matplotlib import pyplot as plt\n\n        if ax is None:\n            ax = plt.subplots(dpi=300, figsize=(8, 7))[1]\n        self_graph = self.graph.copy()\n        node_states = nx.get_node_attributes(self_graph, \"state\", default=0)\n        edge_states = nx.get_edge_attributes(self_graph, \"state\", default=0)\n        if not show_tsp:\n            self_graph.remove_nodes_from([\"pressure\", \"salinity\", \"temperature\"])\n        if not show_unknown:\n            self_graph.remove_nodes_from([n for n, s in node_states.items() if s == 0])\n        if not show_isolated:\n            self_graph.remove_nodes_from(\n                [n for n, d in dict(self_graph.degree).items() if d == 0]\n            )\n        if exclude_nodes:\n            # Excluding nodes just makes them disappear from the graph without caring\n            # about what they were connected to\n            if isinstance(exclude_nodes, str):\n                exclude_nodes = [exclude_nodes]\n            self_graph.remove_nodes_from(exclude_nodes)\n        if skip_nodes:\n            # Skipping nodes removes them but then shows their predecessors as being\n            # directly connected to their children\n            if isinstance(skip_nodes, str):\n                skip_nodes = [skip_nodes]\n            for n in skip_nodes:\n                for p, s in itertools.product(\n                    self_graph.predecessors(n), self_graph.successors(n)\n                ):\n                    self_graph.add_edge(p, s)\n                    if edge_states[(p, n)] + edge_states[(n, s)] == 4:\n                        new_state = {(p, s): 2}\n                    else:\n                        new_state = {(p, s): 0}\n                    nx.set_edge_attributes(self_graph, new_state, name=\"state\")\n                    edge_states.update(new_state)\n                self_graph.remove_node(n)\n        state_colours = {0: \"xkcd:grey\", 1: \"xkcd:grass\", 2: \"xkcd:azure\"}\n        node_colour = [state_colours[node_states[n]] for n in nx.nodes(self_graph)]\n        edge_colour = [state_colours[edge_states[e]] for e in nx.edges(self_graph)]\n        pos = nx.nx_agraph.graphviz_layout(self.graph, prog=prog_graphviz)\n        node_labels = {k: k for k in self_graph.nodes}\n        for k, v in set_node_labels.items():\n            if k in node_labels:\n                node_labels[k] = v\n        nx.draw_networkx(\n            self_graph,\n            ax=ax,\n            clip_on=False,\n            with_labels=True,\n            node_color=node_colour,\n            edge_color=edge_colour,\n            pos=pos,\n            labels=node_labels,\n        )\n        return ax\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.adjust","title":"<code>adjust(temperature=None, pressure=None, store_steps=1, method_fCO2=1, opt_which_fCO2_insitu=1, bh_upsilon=None)</code>","text":"<p>Adjust the system to a different temperature and/or pressure.</p> <p>Parameters:</p> Name Type Description Default <code>temperature</code> <code>float</code> <p>Temperature in \u00b0C to adjust to.  If <code>None</code>, temperature is not adjusted.</p> <code>None</code> <code>pressure</code> <code>float</code> <p>Hydrostatic pressure in dbar to adjust to.  If <code>None</code>, pressure is not adjusted.</p> <code>None</code> <code>store_steps</code> <code>int</code> <p>Whether/which non-requested parameters calculated during intermediate calculation steps should be stored.  The options are:</p> <ul> <li><code>0</code>: Store only the requested parameters.</li> <li><code>1</code>: Store the requested and most commonly used set of intermediate   parameters (default).</li> <li><code>2</code>: Store the requested and complete set of intermediate parameters.</li> </ul> <code>1</code> <code>method_fCO2</code> <code>int</code> <p>If this is a single-parameter system, which method to use for the adjustment.  The options are:</p> <ul> <li><code>1</code>: parameterisation of H24 (default).</li> <li><code>2</code>: constant bh fitted to TOG93 dataset by H24.</li> <li><code>3</code>: constant theoretical bh of H24.</li> <li><code>4</code>: user-specified bh with the equations of H24.</li> <li><code>5</code>: linear fit of TOG93.</li> <li><code>6</code>: quadratic fit of TOG93.</li> </ul> <code>1</code> <code>opt_which_fCO2_insitu</code> <code>int</code> <p>If this is a single-parameter system and <code>method_fCO2</code> is <code>1</code>, whether:   - <code>1</code> the input condition (starting; default) or   - <code>2</code> output condition (adjusted) temperature should be used to calculate b_h.</p> <code>1</code> <code>bh_upsilon</code> <code>float</code> <p>If this is a single-parameter system and <code>method_fCO2</code> is <code>4</code>, then the value of b_h in J/mol must be specified here.</p> <code>None</code> <p>Returns:</p> Type Description <code>CO2System</code> <p>A new <code>CO2System</code> with all values adjusted to the requested temperature(s) and/or pressure(s).</p> Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def adjust(\n    self,\n    temperature=None,\n    pressure=None,\n    store_steps=1,\n    method_fCO2=1,\n    opt_which_fCO2_insitu=1,\n    bh_upsilon=None,\n):\n    \"\"\"Adjust the system to a different temperature and/or pressure.\n\n    Parameters\n    ----------\n    temperature : float, optional\n        Temperature in \u00b0C to adjust to.  If `None`, temperature is not adjusted.\n    pressure : float, optional\n        Hydrostatic pressure in dbar to adjust to.  If `None`, pressure is not\n        adjusted.\n    store_steps : int, optional\n        Whether/which non-requested parameters calculated during intermediate\n        calculation steps should be stored.  The options are:\n\n          - `0`: Store only the requested parameters.\n          - `1`: Store the requested and most commonly used set of intermediate\n          parameters (default).\n          - `2`: Store the requested and complete set of intermediate parameters.\n    method_fCO2 : int, optional\n        If this is a single-parameter system, which method to use for the\n        adjustment.  The options are:\n\n          - `1`: parameterisation of H24 (default).\n          - `2`: constant bh fitted to TOG93 dataset by H24.\n          - `3`: constant theoretical bh of H24.\n          - `4`: user-specified bh with the equations of H24.\n          - `5`: linear fit of TOG93.\n          - `6`: quadratic fit of TOG93.\n    opt_which_fCO2_insitu : int, optional\n        If this is a single-parameter system and `method_fCO2` is `1`, whether:\n          - `1` the input condition (starting; default) or\n          - `2` output condition (adjusted) temperature\n        should be used to calculate $b_h$.\n    bh_upsilon : float, optional\n        If this is a single-parameter system and `method_fCO2` is `4`, then the\n        value of $b_h$ in J/mol must be specified here.\n\n    Returns\n    -------\n    CO2System\n        A new `CO2System` with all values adjusted to the requested temperature(s)\n        and/or pressure(s).\n    \"\"\"\n    if self.icase &gt; 100:\n        # If we know (any) two MCS parameters, solve for alkalinity and DIC under\n        # the \"input\" conditions\n        self.solve(parameters=[\"alkalinity\", \"dic\"], store_steps=store_steps)\n        core = {k: self[k] for k in [\"alkalinity\", \"dic\"]}\n        data = {}\n    elif self.icase in [4, 5, 8, 9]:\n        assert pressure is None, (\n            \"Cannot adjust pressure for a single-parameter system!\"\n        )\n        # If we know only one of pCO2, fCO2, xCO2 or CO2(aq), first get fCO2 under\n        # the \"input\" conditions\n        self.solve(parameters=\"fCO2\", store_steps=store_steps)\n        core = {\"fCO2\": self.fCO2}\n        # Then, convert this to the value at the new temperature using the requested\n        # method\n        assert method_fCO2 in range(1, 7), (\n            \"`method_fCO2` must be an integer from 1-6.\"\n        )\n        expUps = self._get_expUps(\n            method_fCO2,\n            temperature,\n            bh_upsilon=bh_upsilon,\n            opt_which_fCO2_insitu=opt_which_fCO2_insitu,\n        )\n        data = {\"fCO2\": core[\"fCO2\"] * expUps}\n    else:\n        warnings.warn(\n            \"Single-parameter temperature adjustments are possible only \"\n            + \"if the known parameter is one of pCO2, fCO2, xCO2 and CO2.\"\n        )\n    # Copy all parameters that are T/P independent into new data dict\n    for k in condition_independent:\n        if k in self.nodes_original:\n            data[k] = self.data[k]\n        elif k in core:\n            data[k] = core[k]\n    # Set temperature and/or pressure to adjusted value(s), unless they are None, in\n    # which case, don't adjust\n    if temperature is not None:\n        data[\"temperature\"] = temperature\n    else:\n        data[\"temperature\"] = self.data[\"temperature\"]\n    if pressure is not None:\n        data[\"pressure\"] = pressure\n    else:\n        data[\"pressure\"] = self.data[\"pressure\"]\n    sys = CO2System(\n        **data,\n        **self.opts,\n        pd_index=self.pd_index,\n        xr_dims=self.xr_dims,\n        xr_shape=self.xr_shape,\n    )\n    sys.solve(parameters=self.data)\n    return sys\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.get_grad","title":"<code>get_grad(var_of, var_wrt)</code>","text":"<p>Compute the derivative of <code>var_of</code> with respect to <code>var_wrt</code> and store it in <code>sys.grads[var_of][var_wrt]</code>.  If there is already a value there, then that value is returned instead of recalculating.</p> <p>Parameters:</p> Name Type Description Default <code>var_of</code> <code>str</code> <p>The name of the variable to get the derivative of.</p> required <code>var_wrt</code> <code>str</code> <p>The name of the variable to get the derivative with respect to.  This must be one of the fixed values provided when creating the <code>CO2System</code>, i.e., listed in its <code>nodes_original</code> attribute.</p> required Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def get_grad(self, var_of, var_wrt):\n    \"\"\"Compute the derivative of `var_of` with respect to `var_wrt` and store it in\n    `sys.grads[var_of][var_wrt]`.  If there is already a value there, then that\n    value is returned instead of recalculating.\n\n    Parameters\n    ----------\n    var_of : str\n        The name of the variable to get the derivative of.\n    var_wrt : str\n        The name of the variable to get the derivative with respect to.  This must\n        be one of the fixed values provided when creating the `CO2System`, i.e.,\n        listed in its `nodes_original` attribute.\n    \"\"\"\n    assert var_wrt in self.nodes_original, (\n        \"`var_wrt` must be one of `sys.nodes_original!`\"\n    )\n    try:  # see if we've already calculated this value\n        d_of__d_wrt = self.grads[var_of][var_wrt]\n    except KeyError:  # only do the calculations if there isn't already a value\n        # We need to know the shape of the variable that we want the grad of, the\n        # easy way to get this is just to solve for it (if that hasn't already been\n        # done)\n        if var_of not in self.data:\n            self.solve(var_of)\n        # Next, we extract the originally set values, which are fixed during the\n        # differentiation\n        values_original = self.get_values_original()\n        other_values_original = values_original.copy()\n        # We have to make sure the value we are differentiating with respect to has\n        # the same shape as the value we want the differential of\n        value_wrt = other_values_original.pop(var_wrt) * np.ones_like(\n            self.data[var_of]\n        )\n        # Here we compute the gradient\n        grad_func = self.get_grad_func(var_of, var_wrt)\n        d_of__d_wrt = grad_func(value_wrt, **other_values_original)\n        # Put the final value into self.grads, first creating a new sub-dict if\n        # necessary\n        if var_of not in self.grads:\n            self.grads[var_of] = {}\n        self.grads[var_of][var_wrt] = d_of__d_wrt\n    return d_of__d_wrt\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.get_grads","title":"<code>get_grads(vars_of, vars_wrt)</code>","text":"<p>Compute the derivatives of <code>vars_of</code> with respect to <code>vars_wrt</code> and store them in <code>sys.grads[var_of][var_wrt]</code>.  If there are already values there, then those values are returned instead of recalculating.</p> <p>Parameters:</p> Name Type Description Default <code>vars_of</code> <code>list</code> <p>The names of the variables to get the derivatives of.</p> required <code>vars_wrt</code> <code>list</code> <p>The names of the variables to get the derivatives with respect to.  These must all be one of the fixed values provided when creating the <code>CO2System</code>, i.e., listed in its <code>nodes_original</code> attribute.</p> required Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def get_grads(self, vars_of, vars_wrt):\n    \"\"\"Compute the derivatives of `vars_of` with respect to `vars_wrt` and store\n    them in `sys.grads[var_of][var_wrt]`.  If there are already values there, then\n    those values are returned instead of recalculating.\n\n    Parameters\n    ----------\n    vars_of : list\n        The names of the variables to get the derivatives of.\n    vars_wrt : list\n        The names of the variables to get the derivatives with respect to.  These\n        must all be one of the fixed values provided when creating the `CO2System`,\n        i.e., listed in its `nodes_original` attribute.\n    \"\"\"\n    if isinstance(vars_of, str):\n        vars_of = [vars_of]\n    if isinstance(vars_wrt, str):\n        vars_wrt = [vars_wrt]\n    for var_of, var_wrt in itertools.product(vars_of, vars_wrt):\n        self.get_grad(var_of, var_wrt)\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.plot_graph","title":"<code>plot_graph(ax=None, exclude_nodes=None, prog_graphviz='neato', show_tsp=True, show_unknown=True, show_isolated=True, skip_nodes=None)</code>","text":"<p>Draw a graph showing the relationships between the different parameters.</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <code>matplotlib axes</code> <p>The axes on which to plot.  If <code>None</code>, a new figure and axes are created.</p> <code>None</code> <code>exclude_nodes</code> <code>list of str</code> <p>List of nodes to exclude from the plot, by default <code>None</code>.  Nodes in this list are not shown, nor are connections to them or through them.</p> <code>None</code> <code>prog_graphviz</code> <code>str</code> <p>Name of Graphviz layout program, by default \"neato\".</p> <code>'neato'</code> <code>show_tsp</code> <code>bool</code> <p>Whether to show temperature, salinity and pressure nodes, by default <code>False</code>.</p> <code>True</code> <code>show_unknown</code> <code>bool</code> <p>Whether to show nodes for parameters that have not (yet) been calculated, by default <code>True</code>.</p> <code>True</code> <code>show_isolated</code> <code>bool</code> <p>Whether to show nodes for parameters that are not connected to the graph, by default <code>True</code>.</p> <code>True</code> <code>skip_nodes</code> <code>bool</code> <p>List of nodes to skip from the plot, by default <code>None</code>.  Nodes in this list are not shown, but the connections between their predecessors and children are still drawn.</p> <code>None</code> <p>Returns:</p> Type Description <code>matplotlib axes</code> <p>The axes on which the graph is plotted.</p> Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def plot_graph(\n    self,\n    ax=None,\n    exclude_nodes=None,\n    prog_graphviz=\"neato\",\n    show_tsp=True,\n    show_unknown=True,\n    show_isolated=True,\n    skip_nodes=None,\n):\n    \"\"\"Draw a graph showing the relationships between the different parameters.\n\n    Parameters\n    ----------\n    ax : matplotlib axes, optional\n        The axes on which to plot.  If `None`, a new figure and axes are created.\n    exclude_nodes : list of str, optional\n        List of nodes to exclude from the plot, by default `None`.  Nodes in this\n        list are not shown, nor are connections to them or through them.\n    prog_graphviz : str, optional\n        Name of Graphviz layout program, by default \"neato\".\n    show_tsp : bool, optional\n        Whether to show temperature, salinity and pressure nodes, by default\n        `False`.\n    show_unknown : bool, optional\n        Whether to show nodes for parameters that have not (yet) been calculated,\n        by default `True`.\n    show_isolated : bool, optional\n        Whether to show nodes for parameters that are not connected to the graph,\n        by default `True`.\n    skip_nodes : bool, optional\n        List of nodes to skip from the plot, by default `None`.  Nodes in this list\n        are not shown, but the connections between their predecessors and children\n        are still drawn.\n\n    Returns\n    -------\n    matplotlib axes\n        The axes on which the graph is plotted.\n    \"\"\"\n    from matplotlib import pyplot as plt\n\n    if ax is None:\n        ax = plt.subplots(dpi=300, figsize=(8, 7))[1]\n    self_graph = self.graph.copy()\n    node_states = nx.get_node_attributes(self_graph, \"state\", default=0)\n    edge_states = nx.get_edge_attributes(self_graph, \"state\", default=0)\n    if not show_tsp:\n        self_graph.remove_nodes_from([\"pressure\", \"salinity\", \"temperature\"])\n    if not show_unknown:\n        self_graph.remove_nodes_from([n for n, s in node_states.items() if s == 0])\n    if not show_isolated:\n        self_graph.remove_nodes_from(\n            [n for n, d in dict(self_graph.degree).items() if d == 0]\n        )\n    if exclude_nodes:\n        # Excluding nodes just makes them disappear from the graph without caring\n        # about what they were connected to\n        if isinstance(exclude_nodes, str):\n            exclude_nodes = [exclude_nodes]\n        self_graph.remove_nodes_from(exclude_nodes)\n    if skip_nodes:\n        # Skipping nodes removes them but then shows their predecessors as being\n        # directly connected to their children\n        if isinstance(skip_nodes, str):\n            skip_nodes = [skip_nodes]\n        for n in skip_nodes:\n            for p, s in itertools.product(\n                self_graph.predecessors(n), self_graph.successors(n)\n            ):\n                self_graph.add_edge(p, s)\n                if edge_states[(p, n)] + edge_states[(n, s)] == 4:\n                    new_state = {(p, s): 2}\n                else:\n                    new_state = {(p, s): 0}\n                nx.set_edge_attributes(self_graph, new_state, name=\"state\")\n                edge_states.update(new_state)\n            self_graph.remove_node(n)\n    state_colours = {0: \"xkcd:grey\", 1: \"xkcd:grass\", 2: \"xkcd:azure\"}\n    node_colour = [state_colours[node_states[n]] for n in nx.nodes(self_graph)]\n    edge_colour = [state_colours[edge_states[e]] for e in nx.edges(self_graph)]\n    pos = nx.nx_agraph.graphviz_layout(self.graph, prog=prog_graphviz)\n    node_labels = {k: k for k in self_graph.nodes}\n    for k, v in set_node_labels.items():\n        if k in node_labels:\n            node_labels[k] = v\n    nx.draw_networkx(\n        self_graph,\n        ax=ax,\n        clip_on=False,\n        with_labels=True,\n        node_color=node_colour,\n        edge_color=edge_colour,\n        pos=pos,\n        labels=node_labels,\n    )\n    return ax\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.propagate","title":"<code>propagate(uncertainty_in, uncertainty_from)</code>","text":"<p>Propagate independent uncertainties through the calculations.  Covariances are not accounted for.</p> <p>New entries are added in the <code>uncertainty</code> attribute, for example:</p> <pre><code>co2s = CO2System(dic=2100, alkalinity=2300)\nco2s.propagate(\"pH\", {\"dic\": 2, \"alkalinity\": 2})\nco2s.uncertainty[\"pH\"][\"total\"]  # total uncertainty in pH\nco2s.uncertainty[\"pH\"][\"dic\"]  # component of ^ due to DIC uncertainty\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>uncertainty_in</code> <code>list</code> <p>The parameters to calculate the uncertainty in.</p> required <code>uncertainty_from</code> <code>dict</code> <p>The parameters to propagate the uncertainty from (keys) and their uncertainties (values).</p> required Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def propagate(self, uncertainty_in, uncertainty_from):\n    \"\"\"Propagate independent uncertainties through the calculations.  Covariances\n    are not accounted for.\n\n    New entries are added in the `uncertainty` attribute, for example:\n\n        co2s = CO2System(dic=2100, alkalinity=2300)\n        co2s.propagate(\"pH\", {\"dic\": 2, \"alkalinity\": 2})\n        co2s.uncertainty[\"pH\"][\"total\"]  # total uncertainty in pH\n        co2s.uncertainty[\"pH\"][\"dic\"]  # component of ^ due to DIC uncertainty\n\n    Parameters\n    ----------\n    uncertainty_in : list\n        The parameters to calculate the uncertainty in.\n    uncertainty_from : dict\n        The parameters to propagate the uncertainty from (keys) and their\n        uncertainties (values).\n    \"\"\"\n    self.solve(uncertainty_in)\n    if isinstance(uncertainty_in, str):\n        uncertainty_in = [uncertainty_in]\n    for var_in in uncertainty_in:\n        # This should always be reset to zero and all values wiped, even if it\n        # already exists (so you don't end up with old uncertainty_from components\n        # from a previous calculation which are no longer part of the total)\n        self.uncertainty[var_in] = {\"total\": np.zeros_like(self.data[var_in])}\n        u_total = self.uncertainty[var_in][\"total\"]\n        for var_from, u_from in uncertainty_from.items():\n            is_pk = var_from.startswith(\"pk_\")\n            if is_pk:\n                # If the uncertainty is given in terms of a pK value, we do the\n                # calculations as if it were a K value, and convert at the end\n                var_from = var_from[1:]\n            is_fractional = var_from.endswith(\"__f\")\n            if is_fractional:\n                # If the uncertainty is fractional, multiply through by this\n                var_from = var_from[:-3]\n                u_from = self.data[var_from] * u_from\n            if var_from in self.nodes_original:\n                self.get_grad(var_in, var_from)\n                u_part = np.abs(self.grads[var_in][var_from] * u_from)\n            else:\n                # If the uncertainty is from some internally calculated value, then\n                # we need to make a second CO2System where that value is one of the\n                # known inputs, and get the grad from that\n                self.solve(var_from)\n                data = self.get_values_original()\n                data.update({var_from: self.data[var_from]})\n                sys = CO2System(**data, **self.opts)\n                sys.get_grad(var_in, var_from)\n                u_part = np.abs(sys.grads[var_in][var_from] * u_from)\n            # Add the p back and convert value, if necessary\n            if is_pk:\n                u_part = u_part * np.log(10) * np.abs(sys.data[var_from])\n                var_from = \"p\" + var_from\n            if is_fractional:\n                var_from += \"__f\"\n            self.uncertainty[var_in][var_from] = u_part\n            u_total = u_total + u_part**2\n        self.uncertainty[var_in][\"total\"] = np.sqrt(u_total)\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.solve","title":"<code>solve(parameters=None, store_steps=1)</code>","text":"<p>Calculate parameter(s) and store them internally.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>str or list of str</code> <p>Which parameter(s) to calculate and store, by default None, in which case all possible parameters are calculated and stored internally.</p> <code>None</code> <code>store_steps</code> <code>int</code> <p>Whether/which non-requested parameters calculated during intermediate calculation steps should be stored, by default 1.  The options are     0 - store only the specifically requested parameters,     1 - store the most used set of intermediate parameters, or     2 - store the complete set of parameters.</p> <code>1</code> Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def solve(self, parameters=None, store_steps=1):\n    \"\"\"Calculate parameter(s) and store them internally.\n\n    Parameters\n    ----------\n    parameters : str or list of str, optional\n        Which parameter(s) to calculate and store, by default None, in which case\n        all possible parameters are calculated and stored internally.\n    store_steps : int, optional\n        Whether/which non-requested parameters calculated during intermediate\n        calculation steps should be stored, by default 1.  The options are\n            0 - store only the specifically requested parameters,\n            1 - store the most used set of intermediate parameters, or\n            2 - store the complete set of parameters.\n    \"\"\"\n    # Parse user-provided parameters (if there are any)\n    if parameters is None:\n        # If no parameters are provided, then we solve for everything possible\n        parameters = list(self.graph.nodes)\n    elif isinstance(parameters, str):\n        # Allow user to provide a string if only one parameter is desired\n        parameters = [parameters]\n    parameters = set(parameters)  # get rid of duplicates\n    self.requested |= parameters\n    self_data = self.data.copy()  # what was already known before this solve\n    # Remove known nodes from a copy of self.graph, so that ancestors of known nodes\n    # are not unnecessarily recomputed\n    graph_unknown = self.graph.copy()\n    graph_unknown.remove_nodes_from([k for k in self_data if k not in parameters])\n    # Add intermediate parameters that we need to know in order to calculate the\n    # requested parameters\n    parameters_all = parameters.copy()\n    for p in parameters:\n        parameters_all = parameters_all | nx.ancestors(graph_unknown, p)\n    # Convert the set of parameters into a list, exclude already-known ones, and\n    # organise the list into the order required for calculations\n    parameters_all = [\n        p\n        for p in nx.topological_sort(self.graph)\n        if p in parameters_all and p not in self_data\n    ]\n    store_parameters = []\n    for p in parameters_all:\n        priors = self.graph.pred[p]\n        if len(priors) == 0 or all([r in self_data for r in priors]):\n            self_data[p] = self.funcs[p](\n                *[\n                    self_data[r]\n                    for r in self.funcs[p].__code__.co_varnames[\n                        : self.funcs[p].__code__.co_argcount\n                    ]\n                ]\n            )\n            store_here = (\n                #  If store_steps is 0, store only requested parameters\n                (store_steps == 0 and p in parameters)\n                | (\n                    # If store_steps is 1, store all but the equilibrium constants\n                    # on the seawater scale, at 1 atm and their pressure-correction\n                    # factors, and a few selected others\n                    store_steps == 1\n                    and not p.startswith(\"factor_k_\")\n                    and not (p.startswith(\"k_\") and p.endswith(\"_sws\"))\n                    and not p.endswith(\"_1atm\")\n                    and p not in [\"sws_to_opt\", \"opt_to_free\", \"ionic_strength\"]\n                )\n                |  # If store_steps is 2, store everything\n                (store_steps == 2)\n            )\n            if store_here:\n                store_parameters.append(p)\n                # state = 2 means that the value was calculated internally\n                nx.set_node_attributes(self.graph, {p: 2}, name=\"state\")\n                for f in self.funcs[p].__code__.co_varnames[\n                    : self.funcs[p].__code__.co_argcount\n                ]:\n                    nx.set_edge_attributes(self.graph, {(f, p): 2}, name=\"state\")\n    # Get rid of jax overhead on results\n    self_data = {k: v for k, v in self_data.items() if k in store_parameters}\n    _remove_jax_overhead(self_data)\n    self.data.update(self_data)\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.to_pandas","title":"<code>to_pandas(parameters=None, store_steps=1)</code>","text":"<p>Return parameters as a pandas <code>Series</code> or <code>DataFrame</code>.  All parameters should be scalar or one-dimensional vectors of the same size.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>str or list of str</code> <p>The parameter(s) to return.  These are solved for if not already available. If <code>None</code>, then all parameters that have already been solved for are returned.</p> <code>None</code> <code>store_steps</code> <code>int</code> <p>See <code>solve</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>Series or DataFrame</code> <p>The parameter(s) as a <code>pd.Series</code> (if <code>parameters</code> is a <code>str</code>) or as a <code>pd.DataFrame</code> (if <code>parameters</code> is a <code>list</code>) with the original pandas index passed into the <code>CO2System</code> as <code>data</code>.  If <code>data</code> was not a <code>pd.DataFrame</code> then the default index will be used.</p> Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def to_pandas(self, parameters=None, store_steps=1):\n    \"\"\"Return parameters as a pandas `Series` or `DataFrame`.  All parameters should\n    be scalar or one-dimensional vectors of the same size.\n\n    Parameters\n    ----------\n    parameters : str or list of str, optional\n        The parameter(s) to return.  These are solved for if not already available.\n        If `None`, then all parameters that have already been solved for are\n        returned.\n    store_steps : int, optional\n        See `solve`.\n\n    Returns\n    -------\n    pd.Series or pd.DataFrame\n        The parameter(s) as a `pd.Series` (if `parameters` is a `str`) or as a\n        `pd.DataFrame` (if `parameters` is a `list`) with the original pandas index\n        passed into the `CO2System` as `data`.  If `data` was not a `pd.DataFrame`\n        then the default index will be used.\n    \"\"\"\n    try:\n        import pandas as pd\n\n        if parameters is None:\n            parameters = self.keys()\n        self.solve(parameters=parameters, store_steps=store_steps)\n        if isinstance(parameters, str):\n            return pd.Series(data=self[parameters], index=self.pd_index)\n        else:\n            return pd.DataFrame(\n                {\n                    p: pd.Series(\n                        data=self[p] * np.ones(self.pd_index.shape),\n                        index=self.pd_index,\n                    )\n                    for p in parameters\n                }\n            )\n    except ImportError:\n        warnings.warn(\"pandas could not be imported.\")\n</code></pre>"},{"location":"api/#PyCO2SYS.CO2System.to_xarray","title":"<code>to_xarray(parameters=None, store_steps=1)</code>","text":"<p>Return parameters as an xarray <code>DataArray</code> or <code>Dataset</code>.</p> <p>Parameters:</p> Name Type Description Default <code>parameters</code> <code>str or list of str</code> <p>The parameter(s) to return.  These are solved for if not already available. If <code>None</code>, then all parameters that have already been solved for are returned.</p> <code>None</code> <code>store_steps</code> <code>int</code> <p>See <code>solve</code>.</p> <code>1</code> <p>Returns:</p> Type Description <code>DataArray or Dataset</code> <p>The parameter(s) as a <code>xr.DataArray</code> (if <code>parameters</code> is a <code>str</code>) or as a <code>xr.Dataset</code> (if <code>parameters</code> is a <code>list</code>) with the original xarray dimensions passed into the <code>CO2System</code> as <code>data</code>.  If <code>data</code> was not an <code>xr.Dataset</code> then this function will not work.</p> Source code in <code>PyCO2SYS/engine.py</code> <pre><code>def to_xarray(self, parameters=None, store_steps=1):\n    \"\"\"Return parameters as an xarray `DataArray` or `Dataset`.\n\n    Parameters\n    ----------\n    parameters : str or list of str, optional\n        The parameter(s) to return.  These are solved for if not already available.\n        If `None`, then all parameters that have already been solved for are\n        returned.\n    store_steps : int, optional\n        See `solve`.\n\n    Returns\n    -------\n    xr.DataArray or xr.Dataset\n        The parameter(s) as a `xr.DataArray` (if `parameters` is a `str`) or as a\n        `xr.Dataset` (if `parameters` is a `list`) with the original xarray\n        dimensions passed into the `CO2System` as `data`.  If `data` was not an\n        `xr.Dataset` then this function will not work.\n    \"\"\"\n    assert self.xr_dims is not None and self.xr_shape is not None, (\n        \"`data` was not provided as an `xr.Dataset` \"\n        + \"when creating this `CO2System`.\"\n    )\n    try:\n        import xarray as xr\n\n        if parameters is None:\n            parameters = self.keys()\n        self.solve(parameters=parameters, store_steps=store_steps)\n        if isinstance(parameters, str):\n            ndims = self._get_xr_ndims(parameters)\n            return xr.DataArray(np.squeeze(self[parameters]), dims=ndims)\n        else:\n            return xr.Dataset(\n                {\n                    p: xr.DataArray(np.squeeze(self[p]), dims=self._get_xr_ndims(p))\n                    for p in parameters\n                }\n            )\n    except ImportError:\n        warnings.warn(\"xarray could not be imported.\")\n</code></pre>"},{"location":"detail/","title":"Arguments and results","text":"<p>This page provides a comprehensive overview of all possible arguments to PyCO2SYS and the results it can compute.  It assumes familiarity with the basic syntax of <code>pyco2.sys</code> (see the Quick-start guide).</p> <p>Content, not concentration</p> <p>For all arguments and results in \u03bcmol\u00a0kg<sup>\u20131</sup>, the \"kg\" refers to the total solution, not H<sub>2</sub>O.  These are therefore accurately termed substance content or molinity values (as opposed to concentration or molality).</p>"},{"location":"detail/#keyword-arguments","title":"Keyword arguments","text":"<p>Each argument to <code>pyco2.sys</code> can be either a single scalar value, or a NumPy array containing a series of values.  A combination of different multidimensional array shapes and sizes is allowed as long as they can all be broadcasted with each other.</p>"},{"location":"detail/#carbonate-system-parameters","title":"Carbonate system parameters","text":"<p>Up to two carbonate system parameters can be provided.</p> <p>Carbonate system parameters</p> <p>If two parameters are provided, these can be any pair of:</p> <ul> <li><code>alkalinity</code>: total alkalinity in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>dic</code>: dissolved inorganic carbon in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>pH</code>: pH on the total, seawater, free or NBS scale.  Which scale is given by <code>opt_pH_scale</code>.</li> <li><code>HCO3</code>: bicarbonate ion in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li>Any one of:<ul> <li><code>pCO2</code>: partial pressure of CO<sub>2</sub> in \u03bcatm,</li> <li><code>fCO2</code>: fugacity of CO<sub>2</sub> in \u03bcatm,</li> <li><code>CO2</code>: aqueous CO<sub>2</sub> in \u03bcmol\u00a0kg<sup>\u20131</sup>, or</li> <li><code>xCO2</code>: dry-air mole fraction of CO<sub>2</sub> in ppm.</li> </ul> </li> <li>Any one of:<ul> <li><code>CO3</code>: carbonate ion in \u03bcmol\u00a0kg<sup>\u20131</sup>,</li> <li><code>saturation_calcite</code>: saturation state with respect to calcite, or</li> <li><code>saturation_aragonite</code>: saturation state with respect to aragonite.</li> </ul> </li> </ul> <p>If one parameter is provided, then the full marine carbonate system cannot be solved, but some results can be calculated.  The single parameter can be any of:</p> <ul> <li><code>pCO2</code>, <code>fCO2</code>, <code>CO2</code> or <code>xCO2</code>: the others in this group of parameters can be calculated and adjusted to different temperatures.</li> <li><code>pH</code>, which can be converted to different scales.</li> </ul> <p>If no carbonate system parameters are provided, then all equilibrium constants and total salt contents can still be calculated.</p>"},{"location":"detail/#hydrographic-conditions","title":"Hydrographic conditions","text":"<p>If not provided, these revert to default values.</p> <p>Hydrographic conditions</p> <ul> <li><code>salinity</code>: practical salinity (default 35).</li> <li><code>temperature</code>: temperature in \u00b0C (default 25 \u00b0C) at which the carbonate system parameters are provided.</li> <li><code>pressure</code>: hydrostatic pressure in dbar (default 0 dbar) at which the carbonate system parameters are provided.</li> <li><code>pressure_atmosphere</code>: atmospheric pressure in atm (default 1 atm).</li> </ul>"},{"location":"detail/#nutrients-and-other-solutes","title":"Nutrients and other solutes","text":"<p>Nutrients default to zero if not provided, while other solutes are calculated from salinity.</p> <p>Nutrients and other solutes</p> <p>Some default to zero if not provided:</p> <ul> <li><code>total_silicate</code>: total silicate in \u03bcmol\u00a0kg<sup>\u20131</sup> (default 0 \u03bcmol\u00a0kg<sup>\u20131</sup>) ([\\mathrm{Si(OH)}_4] + [\\mathrm{SiO(OH)_3}^-]).</li> <li><code>total_phosphate</code>: total phosphate in \u03bcmol\u00a0kg<sup>\u20131</sup> (default 0 \u03bcmol\u00a0kg<sup>\u20131</sup>) ([\\mathrm{H}_3\\mathrm{PO}_4] + [\\mathrm{H}_2\\mathrm{PO}_4^-] + [\\mathrm{HPO}_4^{2-}] + [\\mathrm{PO}_4^{3-}]).</li> <li><code>total_ammonia</code>: total ammonia in \u03bcmol\u00a0kg<sup>\u20131</sup> (default 0 \u03bcmol\u00a0kg<sup>\u20131</sup>) ([\\mathrm{NH}_3] + [\\mathrm{NH}_4^+]).</li> <li><code>total_sulfide</code>: total hydrogen sulfide in \u03bcmol\u00a0kg<sup>\u20131</sup> (default 0 \u03bcmol\u00a0kg<sup>\u20131</sup>) ([\\mathrm{H}_2\\mathrm{S}] + [\\mathrm{HS}^-]).</li> </ul> <p>Others are calculated from salinity if not provided:</p> <ul> <li><code>total_borate</code>: total borate in \u03bcmol\u00a0kg<sup>\u20131</sup> ([\\mathrm{B(OH)}_3] + [\\mathrm{B(OH)}_4^-]).</li> <li><code>total_fluoride</code>: total fluoride in \u03bcmol\u00a0kg<sup>\u20131</sup> ([\\mathrm{HF}] + [\\mathrm{F}^-]).</li> <li><code>total_sulfate</code>: total sulfate in \u03bcmol\u00a0kg<sup>\u20131</sup> ([\\mathrm{HSO}_4^-] + [\\mathrm{SO}_4^2-]).</li> <li><code>Ca</code>: dissolved calcium in \u03bcmol\u00a0kg<sup>\u20131</sup> ([\\mathrm{Ca}^{2+}]).</li> </ul> <p>If these are provided then their parameterisation settings are ignored.</p>"},{"location":"detail/#settings","title":"Settings","text":""},{"location":"detail/#ph-scale","title":"pH scale","text":"<p>If <code>pH</code> is provided as an known marine carbonate system parameter, the pH scale that it is reported on can be specified with <code>opt_pH_scale</code>.  All equilibrium constants will also be calculated on the same scale.</p> <p>pH scale</p> <ul> <li> <p><code>opt_pH_scale</code>: which pH scale was used for <code>pH</code>, as defined by ZW01:</p> <ul> <li><code>1</code>: total (default), i.e. \\mathrm{pH} = -\\log_{10} ([\\mathrm{H}^+] + [\\mathrm{HSO}_4^-]).</li> <li><code>2</code>: seawater, i.e. \\mathrm{pH} = -\\log_{10} ([\\mathrm{H}^+] + [\\mathrm{HSO}_4^-] + [\\mathrm{HF}]).</li> <li><code>3</code>: free, i.e. \\mathrm{pH} = -\\log_{10} [\\mathrm{H}^+].</li> <li><code>4</code>: NBS, i.e. relative to NBS/NIST reference standards.</li> </ul> </li> <li> <p><code>opt_fH</code>: how the hydrogen ion activity coefficient is calculated, for conversions to/from the NBS scale:</p> <ul> <li><code>1</code>: TWB82 (default).</li> <li><code>2</code>: PTBO87, for GEOSECS compatibility.</li> <li><code>3</code>: the coefficient is set to 1, for freshwater.</li> </ul> </li> </ul>"},{"location":"detail/#carbonic-acid-dissociation","title":"Carbonic acid dissociation","text":"<p>Carbonic acid dissociation</p> <ul> <li> <p><code>opt_k_carbonic</code>: which set of equilibrium constant parameterisations to use for carbonic acid dissociation.  The valid temperature (T) and salinity (S) ranges, original pH scale, and type of material measured to derive each set of constants are shown.</p> <ul> <li><code>1</code>: RRV93 (0 &lt; T &lt; 45 \u00b0C, 5 &lt; S &lt; 45, total scale, artificial seawater).</li> <li><code>2</code>: GP89 (\u22121 &lt; T &lt; 40 \u00b0C, 10 &lt; S &lt; 50, seawater scale, artificial seawater).</li> <li><code>3</code>: H73a and H73b refit by DM87 (2 &lt; T &lt; 35 \u00b0C, 20 &lt; S &lt; 40, seawater scale, artificial seawater).</li> <li><code>4</code>: MCHP73 refit by DM87 (2 &lt; T &lt; 35 \u00b0C, 20 &lt; S &lt; 40, seawater scale, real seawater).</li> <li><code>5</code>: H73a, H73b and MCHP73 refit by DM87 (2 &lt; T &lt; 35 \u00b0C, 20 &lt; S &lt; 40, seawater scale, artificial seawater).</li> <li><code>6</code>: MCHP73 aka \"GEOSECS\" (2 &lt; T &lt; 35 \u00b0C, 19 &lt; S &lt; 43, NBS scale, real seawater).</li> <li><code>7</code>: MCHP73 without certain species aka \"Peng\" (2 &lt; T &lt; 35 \u00b0C, 19 &lt; S &lt; 43, NBS scale, real seawater).</li> <li><code>8</code>: M79 (0 &lt; T &lt; 50 \u00b0C, S = 0, freshwater only).</li> <li><code>9</code>: CW98 (2 &lt; T &lt; 30 \u00b0C, 0 &lt; S &lt; 40, NBS scale, real estuarine seawater).</li> <li><code>10</code>: LDK00 (default) (2 &lt; T &lt; 35 \u00b0C, 19 &lt; S &lt; 43, total scale, real seawater).</li> <li><code>11</code>: MM02 (0 &lt; T &lt; 45 \u00b0C, 5 &lt; S &lt; 42, seawater scale, real seawater).</li> <li><code>12</code>: MPL02 (\u22121.6 &lt; T &lt; 35 \u00b0C, 34 &lt; S &lt; 37, seawater scale, field measurements).</li> <li><code>13</code>: MGH06 (0 &lt; T &lt; 50 \u00b0C, 1 &lt; S &lt; 50, seawater scale, real seawater).</li> <li><code>14</code>: M10 (0 &lt; T &lt; 50 \u00b0C, 1 &lt; S &lt; 50, seawater scale, real seawater).</li> <li><code>15</code>: WMW14 (0 &lt; T &lt; 45 \u00b0C, 0 &lt; S &lt; 45, seawater scale, real seawater).</li> <li><code>16</code>: SLH20  (\u22121.67 &lt; T &lt; 31.80 \u00b0C, 30.73 &lt; S &lt; 37.57, total scale, field measurements).</li> <li><code>17</code>: SB21 (15 &lt; T &lt; 35 \u00b0C, 19.6 &lt; S &lt; 41, total scale, real seawater).</li> <li><code>18</code>: PLR18 (\u20136 &lt; T &lt; 25 \u00b0C, 33 &lt; S &lt; 100, total scale, real seawater).</li> </ul> </li> <li> <p><code>opt_factor_k_H2CO3</code>: first carbonic acid dissociation constant pressure correction:</p> <ul> <li><code>1</code>: M95 (default).</li> <li><code>2</code>: EG70, for GEOSECS compatibility.</li> <li><code>3</code>: M83, for freshwater.</li> </ul> </li> <li> <p><code>opt_factor_k_HCO3</code>: second carbonic acid dissociation constant pressure correction:</p> <ul> <li><code>1</code>: M95 (default).</li> <li><code>2</code>: EG70, for GEOSECS compatibility.</li> <li><code>3</code>: M83, for freshwater.</li> </ul> </li> </ul>"},{"location":"detail/#other-dissociation-constants","title":"Other dissociation constants","text":"<p>Other dissociation constants</p> <ul> <li> <p><code>opt_k_HSO4</code>: which parameterisation to use to model bisulfate dissociation:</p> <ul> <li><code>1</code>: D90a (default).</li> <li><code>2</code>: KRCB77.</li> <li><code>3</code>: WM13 with the corrections of WMW14.</li> </ul> </li> <li> <p><code>opt_k_HF</code>: which parameterisation to use for hydrogen fluoride dissociation:</p> <ul> <li><code>1</code>: DR79 (default).</li> <li><code>2</code>: PF87.</li> </ul> </li> <li> <p><code>opt_k_BOH3</code>: which parameterisation to use for boric acid dissociation:</p> <ul> <li><code>1</code>: D90b (default).</li> <li><code>2</code>: LTB69, for GEOSECS compatibility.</li> </ul> </li> <li> <p><code>opt_k_phosphate</code>: which parameterisation to use for phosphoric acid dissociation:</p> <ul> <li><code>1</code>: YM95 (default).</li> <li><code>2</code>: KP67, for GEOSECS compatibility.</li> </ul> </li> <li> <p><code>opt_k_NH3</code>: which parameterisation to use for ammonium dissociation:</p> <ul> <li><code>1</code>: CW95 (default).</li> <li><code>2</code>: YM95.</li> </ul> </li> <li> <p><code>opt_k_Si</code>: which parameterisation to use for silicate dissociation:</p> <ul> <li><code>1</code>: YM95 (default).</li> <li><code>2</code>: SMB64, for GEOSECS compatibility.</li> </ul> </li> <li> <p><code>opt_k_calcite</code>: which parameterisation to use for the saturation state with respect to :</p> <ul> <li><code>1</code>: M83 (default).</li> <li><code>2</code>: I75, for GEOSECS compatibility.</li> </ul> </li> <li> <p><code>opt_k_aragonite</code>: which parameterisation to use for the saturation state with respect to :</p> <ul> <li><code>1</code>: M83 (default).</li> <li><code>2</code>: ICHP73, for GEOSECS compatibility.</li> </ul> </li> <li> <p><code>opt_k_H2O</code>: which parameterisation to use for water dissociation:</p> <ul> <li><code>1</code>: M95 (default).</li> <li><code>2</code>: M79, for GEOSECS compatibility.</li> <li><code>3</code>: HO58 refit by M79, for freshwater.</li> </ul> </li> </ul>"},{"location":"detail/#other-dissociation-constant-pressure-corrections","title":"Other dissociation constant pressure corrections","text":"<p>Other dissociation constant pressure corrections</p> <ul> <li> <p><code>opt_factor_k_BOH3</code>: boric acid dissociation constant pressure correction:</p> <ul> <li><code>1</code>: M79 (default).</li> <li><code>2</code>: EG70, for GEOSECS compatibility.</li> </ul> </li> <li> <p><code>opt_factor_k_H2O</code>: water dissociation constant pressure correction:</p> <ul> <li><code>1</code>: M95 (default).</li> <li><code>2</code>: M83, for freshwater.</li> </ul> </li> </ul>"},{"location":"detail/#total-salt-contents","title":"Total salt contents","text":"<p>These settings are ignored if their values are provided as arguments.</p> <p>Total salt contents</p> <ul> <li> <p><code>opt_total_borate</code>: which boron:salinity relationship is used to calculate total borate (ignored if the <code>total_borate</code> argument is provided):</p> <ul> <li><code>1</code>: U74 (default).</li> <li><code>2</code>: LKB10.</li> <li><code>3</code>: KSK18, for the Baltic Sea.</li> </ul> </li> <li> <p><code>opt_Ca</code>: which calcium:salinity relationship is used to calculate dissolved calcium (ignored if the <code>Ca</code> argument is provided):</p> <ul> <li><code>1</code>: RT67 (default).</li> <li><code>2</code>: C65, for GEOSECS compatibility.</li> </ul> </li> </ul>"},{"location":"detail/#other-settings","title":"Other settings","text":"<p>Other settings</p> <ul> <li> <p><code>opt_gas_constant</code>: what value to use for the universal gas constant (<code>gas_constant</code>):</p> <ul> <li><code>1</code>: DOEv2 (consistent with other CO2SYS software before July 2020).</li> <li><code>2</code>: DOEv3.</li> <li><code>3</code>: 2018 CODATA (default).</li> </ul> </li> <li> <p><code>opt_fugacity_factor</code>: how to convert between partial pressure and fugacity of CO<sub>2</sub> (<code>pCO2</code> and <code>fCO2</code>):</p> <ul> <li><code>1</code>: using a fugacity factor (default).</li> <li><code>2</code>: assuming that partial pressure and fugacity are equal, for compatibility with GEOSECS.</li> </ul> </li> <li> <p><code>opt_HCO3_root</code>: if DIC and bicarbonate ion are the known carbonate system parameter pair, then there are two possible valid solutions (e.g., HLSP22):</p> <ul> <li><code>1</code>: find the low-pH solution.</li> <li><code>2</code>: find the high-pH solution (default). </li> </ul> </li> <li> <p><code>opt_fCO2_temperature</code>: how to calculate the temperature-sensitivity of fCO<sub>2</sub> (<code>upsilon</code>) when only one marine carbonate system parameter is known:</p> <ul> <li><code>1</code>: H24 parameterisation (default).</li> <li><code>2</code>: TOG93 linear fit.</li> <li><code>3</code>: TOG93 quadratic fit.</li> </ul> </li> </ul>"},{"location":"detail/#equilibrium-constants","title":"Equilibrium constants","text":"<p>All of the equilibrium constants needed by PyCO2SYS are calculated internally from temperature, salinity and pressure, and returned in the results.  However, values for any of these constants can be provided instead when calling <code>pyco2.sys</code>.  They should be provided on the pH scale indicated by <code>opt_pH_scale</code>.</p> <p>To do this, the arguments should have the same keywords as the corresponding results dict keys.  For example, to provide a custom water dissociation constant value of pK 14, use <code>k_H2O=1e-14</code>.</p>"},{"location":"detail/#results","title":"Results","text":"<p>See Advanced results access for a more detailed overview of the different ways that the results keys in the sections below can be solved for and accessed from a <code>CO2System</code>.</p>"},{"location":"detail/#pyco2sys-arguments","title":"<code>pyco2.sys</code> arguments","text":"<p>All keyword arguments that can be provided to <code>pyco2.sys</code> and are not settings (i.e., do not begin with <code>opt_</code>) are also available as results with the same keyword.</p> <p>Settings arguments can be found at <code>co2s.opts</code>.  They should not be modified there - doing so will have unpredictable consequences for future calculations.</p>"},{"location":"detail/#ph","title":"pH","text":"<p>pH</p> <ul> <li><code>pH</code>: pH on the scale specified by <code>opt_pH_scale</code>.</li> <li><code>pH_total</code>: pH on the total scale.</li> <li><code>pH_sws</code>: pH on the seawater scale.</li> <li><code>pH_free</code>: pH on the free scale.</li> <li><code>pH_nbs</code>: pH on the NBS scale.</li> <li><code>fH</code>: activity coefficient of H<sup>+</sup> for conversions to and from the NBS scale.</li> </ul>"},{"location":"detail/#chemical-speciation","title":"Chemical speciation","text":"<p>Chemical speciation</p> <ul> <li><code>H_free</code>: \"free\" proton in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>OH</code>: hydroxide ion in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>CO3</code>: carbonate ion in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>HCO3</code>: bicarbonate ion in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>CO2</code>: aqueous CO<sub>2</sub> in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>BOH4</code>: tetrahydroxyborate [\\text{B(OH)}_4^-] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>BOH3</code>: boric acid [\\text{B(OH)}_3] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>H3PO4</code>: phosphoric acid [\\text{H}_3\\text{PO}_4] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>H2PO4</code>: dihydrogen phosphate [\\text{H}_2\\text{PO}_4^-] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>HPO4</code>: monohydrogen phosphate [\\text{HPO}_4^{2-}] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>PO4</code>: phosphate [\\text{PO}_4^{3-}] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>H4SiO4</code>: orthosilicic acid [\\text{Si(OH)}_4] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>H3SiO4</code>: trihydrogen orthosilicate [\\text{SiO(OH)}_3^-] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>NH3</code>: ammonia [\\text{NH}_3] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>NH4</code>: ammonium [\\text{NH}_4^+] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>HS</code>: bisulfide [\\text{HS}^-] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>H2S</code>: hydrogen sulfide [\\text{H}_2\\text{S}] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>HSO4</code>: bisulfate [\\text{HSO}_4^-] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>SO4</code>: sulfate [\\text{SO}_4^{2-}] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>HF</code>: hydrofluoric acid [\\text{HF}] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> <li><code>F</code>: fluoride [\\text{F}^-] in \u03bcmol\u00a0kg<sup>\u20131</sup>.</li> </ul>"},{"location":"detail/#carbonate-mineral-saturation","title":"Carbonate mineral saturation","text":"<p>Carbonate mineral saturation</p> <ul> <li><code>saturation_calcite</code>: saturation state with respect to calcite.</li> <li><code>saturation_aragonite</code>: saturation state with respect to aragonite.</li> </ul>"},{"location":"detail/#chemical-buffer-factors","title":"Chemical buffer factors","text":"<p>Buffer factors are evaluated using automatic differentiation of the complete alkalinity equation.</p> <p>Buffer factors</p> <ul> <li><code>revelle_factor</code>: Revelle factor.</li> <li><code>psi</code>: \u03c8 of FCG94.</li> <li><code>gamma_dic</code>: buffer factor \u03b3<sub>DIC</sub> of ESM10.</li> <li><code>beta_dic</code>: buffer factor \u03b2<sub>DIC</sub> of ESM10.</li> <li><code>omega_dic</code>: buffer factor \u03c9<sub>DIC</sub> of ESM10.</li> <li><code>gamma_alkalinity</code>: buffer factor \u03b3<sub>TA</sub> of ESM10.</li> <li><code>beta_alkalinity</code>: buffer factor \u03b2<sub>TA</sub> of ESM10.</li> <li><code>omega_alkalinity</code>: buffer factor \u03c9<sub>TA</sub> of ESM10.</li> <li><code>Q_isocap</code>: isocapnic quotient of HDW18.</li> <li><code>Q_isocap_approx</code>: isocapnic quotient approximation of HDW18.</li> <li><code>dlnfCO2_dT</code>: temperature derivative of ln(fCO<sub>2</sub>).</li> <li><code>dlnpCO2_dT</code>: temperature derivative of ln(fCO<sub>2</sub>).</li> <li><code>substrate_inhibitor_ratio</code>: substrate:inhibitor ratio of B15 in mol(HCO<sub>3</sub><sup>\u2212</sup>)\u00b7\u03bcmol(H<sup>+</sup>)<sup>\u22121</sup>.</li> </ul>"},{"location":"detail/#equilibrium-constants_1","title":"Equilibrium constants","text":"<p>All equilibrium constants are returned on the pH scale of <code>opt_pH_scale</code> except for <code>k_HF_free</code> and <code>k_HSO4_free</code>, which are always on the free scale.  They are all stoichiometric constants, i.e., defined in terms of reactant contents rather than activities, with the exception of <code>k_CO2</code>, which is a hybrid constant.</p> <p>Equilibrium constants</p> <ul> <li><code>k_CO2</code>: Henry's constant for CO<sub>2</sub>.</li> <li><code>k_H2CO3</code>: first carbonic acid dissociation constant.</li> <li><code>k_HCO3</code>: second carbonic acid dissociation constant.</li> <li><code>k_H2O</code>: water dissociation constant.</li> <li><code>k_BOH3</code>: boric acid dissociation constant.</li> <li><code>k_HF_free</code>: hydrogen fluoride dissociation constant.</li> <li><code>k_HSO4_free</code>: bisulfate dissociation constant.</li> <li><code>k_H3PO4</code>: first phosphoric acid dissociation constant.</li> <li><code>k_H2PO4</code>: second phosphoric acid dissociation constant.</li> <li><code>k_HPO4</code>: third phosphoric acid dissociation constant.</li> <li><code>k_Si</code>: silicic acid dissociation constant.</li> <li><code>k_NH3</code>: ammonia equilibrium constant.</li> <li><code>k_H2S</code>: hydrogen sulfide equilibrium constant.  </li> </ul>"},{"location":"detail/#other-results","title":"Other results","text":"<p>Other results</p> <ul> <li><code>fugacity_factor</code>: fugacity factor for converting between CO<sub>2</sub> partial pressure and fugacity.</li> <li><code>vp_factor</code>: vapour pressure factor for converting between xCO<sub>2</sub> and pCO<sub>2</sub>.    </li> <li><code>gas_constant</code>: ideal gas constant in ml bar<sup>\u22121</sup> mol<sup>\u22121</sup> K<sup>\u22121</sup> (note the unusual unit).</li> </ul>"},{"location":"quick/","title":"Quick-start guide","text":"<p>For most users, the only function needed from PyCO2SYS is <code>pyco2.sys</code>.  This uses the following basic syntax:</p> <pre><code>import PyCO2SYS as pyco2\n\nco2s = pyco2.sys(**kwargs)\nresult = co2s[result_key]\n</code></pre> <p>Results can be calculated and accessed with square brackets, as if <code>co2s</code> were a dict.  (It isn't a dict, it's a <code>CO2System</code>, which means that it can also do some other things too.)</p> <p>The full sets of <code>kwargs</code> that can be provided and results parameters that can be calculated are given in Arguments and results.  Advanced results access gives a more detailed overview of how results can be accessed from a <code>CO2System</code>.  A few commonly used examples are also given below.</p>"},{"location":"quick/#solve-the-marine-carbonate-system","title":"Solve the marine carbonate system","text":"<p>When two marine carbonate system parameters are known, such as total alkalinity and dissolved inorganic carbon (DIC), we can calculate other parameters such as pH:</p> <pre><code># Set up the CO2System\nco2s = pyco2.sys(alkalinity=2250, dic=2100, temperature=15, salinity=34)\n\n# Solve for and return the value of pH\npH = co2s[\"pH\"]\n\n# Solve for and return pCO2 and fCO2 at the same time\nresults = co2s[[\"pCO2\", \"fCO2\"]]\n</code></pre> <p>Each call of <code>pyco2.sys</code> may include a maximum of two known marine carbonate system parameters.</p>"},{"location":"quick/#calculations-without-solving-the-system","title":"Calculations without solving the system","text":"<p>Some properties (mainly equilibrium constants and total salt contents) can be calculated without solving the marine carbonate system, so <code>pyco2.sys</code> can be run with no marine carbonate system parameters:</p> <pre><code># Set up a CO2System under default conditions \n# (temperature 25\u00a0\u00b0C, salinity 35, hydrostatic pressure 0 dbar\n#   - other values could be specified with the appropriate kwargs)\nco2s = pyco2.sys()\n\n# Get water dissociation constant\nk_H2O = co2s[\"k_H2O\"]\n</code></pre>"},{"location":"quick/#use-different-parameterisations","title":"Use different parameterisations","text":"<p>PyCO2SYS contains many different options for the parameterisations of equilibrium constants and total salt contents.  These can be selected using <code>kwargs</code> beginning with <code>opt_</code>, for example:</p> <pre><code># Set up a CO2System with non-default equilibrium constants for carbonic acid\n# and non-default total borate from salinity\nco2s = pyco2.sys(opt_k_carbonic=3, opt_total_borate=2)\n</code></pre> <p>All settings arguments must be single scalar values.</p>"},{"location":"quick/#convert-to-different-temperatures-andor-pressures","title":"Convert to different temperatures and/or pressures","text":"<p>Discussed in more detail in Adjust conditions.</p>"},{"location":"quick/#with-two-known-parameters","title":"With two known parameters","text":"<p>To convert parameters to different temperatures and/or pressures, use the <code>adjust</code> method.  For example, if we had measured alkalinity and pH in the laboratory at 25\u00a0\u00b0C, but wanted to calculate the saturation state with respect to aragonite under in situ conditions:</p> <pre><code># Set up the initial CO2System\nco2s_lab = pyco2.sys(alkalinity=2250, pH=8.1, temperature=25)\n\n# Adjust to in situ conditions (10\u00a0\u00b0C and 1500 dbar hydrostatic pressure)\nco2s_insitu = co2s_lab.adjust(temperature=10, pressure=1500)\nsaturation_aragonite = co2s_insitu[\"saturation_aragonite\"]\n</code></pre>"},{"location":"quick/#with-one-known-parameter","title":"With one known parameter","text":"<p>Any of the partial pressure (<code>pCO2</code>), fugacity (<code>fCO2</code>), dry-air mole fraction (<code>xCO2</code>) or aqueous content (<code>CO2</code>) of CO<sub>2</sub> is known can be converted to different temperatures without a second parameter:</p> <pre><code># Set up the initial CO2System\nco2s_lab = pyco2.sys(pCO2=400, temperature=25)\n\n# Adjust to in situ conditions(10\u00a0\u00b0C and 1500 dbar hydrostatic pressure)\nco2s_insitu = co2s_lab.adjust(temperature=10, pressure=1500)\npCO2_insitu = co2s_insitu[\"pCO2\"]\n</code></pre>"},{"location":"quick/#propagate-uncertainties","title":"Propagate uncertainties","text":"<p>Discussed in more detail in Uncertainty propagation.</p> <p>Uncertainty propagation uses the <code>propagate</code> method.  To get the total uncertainty in pH from independent uncertainties in alkalinity and DIC in the example above, use:</p> <pre><code># Uncertainties in alkalinity and DIC are both 2 \u00b5mol/kg\nco2s.propagate(\"pH\", {\"alkalinity\": 2, \"dic\": 2})\npH_uncertainty = co2s.uncertainty[\"pH\"][\"total\"]\n</code></pre> <p>The individual components of the total uncertainty can also be found, for example:</p> <pre><code>pH_uncertainty_from_dic = co2s.uncertainty[\"pH\"][\"dic\"]\n</code></pre>"},{"location":"quick/#multidimensional-data","title":"Multidimensional data","text":""},{"location":"quick/#numpy-arrays","title":"NumPy arrays","text":"<p>All arguments other than settings can be provided as lists or multidimensional numpy arrays.  The dimensions of different arguments can be different as long as they can be broadcasted together (which they will be!).</p> <pre><code># Define multidimensional arguments\ndic = np.array([2000, 2100, 2200])\npCO2 = np.array([400, 450, 485])\n\n# Set up a CO2System\nco2s_1D = pyco2.sys(dic=dic, pCO2=pCO2)\nalkalinity_1D = co2s_1D[\"alkalinity\"]  # this has the shape (3,)\n\nco2s_2D = pyco2.sys(dic=dic, pCO2=np.vstack(pCO2))\nalkalinity_2D = co2s_2D[\"alkalinity\"]  # this has the shape (3, 3)\n</code></pre>"},{"location":"quick/#pandas-dataframes","title":"Pandas DataFrames","text":"<p>If your data are in a pandas <code>DataFrame</code>, you can provide this as <code>data</code>, and return the results as a pandas <code>Series</code> or <code>DataFrame</code> with consistent indexing:</p> <pre><code># Define known parameters\ndf = pd.DataFrame({\"dic\": [2000, 2100, 2200], \"pCO2\": [400, 450, 485]})\n\n# Set up a CO2System\nco2s = pyco2.sys(data=df, total_silicate=1.5, opt_k_carbonic=9)\n\n# Return a parameter as a Series\npH = co2s.to_pandas(\"pH\")\n\n# Return parameters as a DataFrame\ndf_results = co2s.to_pandas([\"pH\", \"alkalinity\"])\n</code></pre> <p>Running <code>to_pandas</code> with no arguments will return a <code>DataFrame</code> containing all currently calculated parameters.</p>"},{"location":"quick/#xarray-datasets","title":"Xarray Datasets","text":"<p>If your data are in an xarray <code>Dataset</code>, you can provide this as <code>data</code>, and return the results as an xarray <code>DataArray</code> or <code>Dataset</code> with consistent dimensions:</p> <pre><code># Define known parameters\nds = xr.Dataset({\n    \"temperature\": (\"dim_t\", np.arange(0, 35)),\n    \"salinity\": (\"dim_s\", np.arange(30, 40)),\n})\n\n# Set up a CO2System\nco2s = pyco2.sys(data=ds)\n\n# Return a parameter as a DataArray\nk_CO2 = co2s.to_xarray(\"k_CO2\")\n\n# Return parameters as a Dataset\nds_results = co2s.to_xarray([\"k_H2CO3\", \"k_HCO3\"])\n</code></pre> <p>Running <code>to_xarray</code> with no arguments will return a <code>Dataset</code> containing all currently calculated parameters.</p>"},{"location":"refs/","title":"References","text":"<p>Click on each reference to see more details.</p>"},{"location":"refs/#b","title":"B","text":"B15: Bach (2015) Biogeosciences <p>Bach, L. T. (2015). Reconsidering the role of carbonate ion concentration in calcification by marine organisms. Biogeosciences 12(16), 4939\u20134951. doi:10.5194/bg-12-4939-2015.</p> B76: Berner (1976) Am. J. Sci. <p>Berner, R. A. (1976). The solubility of calcite and aragonite in seawater at atmospheric pressure and 34.5 \u2030 salinity. American Journal of Science 276, 713\u2013730. doi:10.2475/ajs.276.6.713.</p> BTSP79: Broecker et al. (1979) Science <p>Broecker, W. S., Takahashi, T., Simpson, H. J., and Peng, T.-H. (1979). Fate of Fossil Fuel Carbon Dioxide and the Global Carbon Budget. Science 206, 409\u2013418. doi:10.1126/science.206.4417.409.</p>"},{"location":"refs/#c","title":"C","text":"C65: Culkin (1965) in Chemical Oceanography <p>Culkin, F. (1965). \u201cThe major constituents of sea water,\u201d in Chemical Oceanography, eds. J. P. Riley and G. Skirrow (London, UK: Academic Press), 121\u2013161.</p> CP68: Culberson &amp; Pytkowicz (1968) Limnol. Oceanogr. <p>Culberson, C., and Pytkowicz, R. M. (1968). Effect of pressure on carbonic acid, boric acid, and the pH in seawater. Limnology and Oceanography 13, 403\u2013417. doi:10.4319/lo.1968.13.3.0403.</p> CW95: Clegg &amp; Whitfield (1995) Geochim. Cosmochim. Acta <p>Clegg, S. L., and Whitfield, M. (1995). A chemical model of seawater including dissolved ammonia and the stoichiometric dissociation constant of ammonia in estuarine water and seawater from \u22122 to 40\u00b0C. Geochimica et Cosmochimica Acta 59, 2403\u20132421. doi:10.1016/0016-7037(95)00135-2.</p> CW98: Cai &amp; Wang (1998) Limnol. Oceanogr. <p>Cai, W.-J., and Wang, Y. (1998). The chemistry, fluxes, and sources of carbon dioxide in the estuarine waters of the Satilla and Altamaha Rivers, Georgia. Limnology and Oceanography 43, 657\u2013668. doi:10.4319/lo.1998.43.4.0657.</p>"},{"location":"refs/#d","title":"D","text":"D90a: Dickson (1990) J. Chem. Thermodyn. <p>Dickson, A. G. (1990). Standard potential of the reaction: AgCl(s) + 0.5 H<sub>2</sub>(g) = Ag(s) + HCl(aq), and the standard acidity constant of the ion HSO<sub>4</sub><sup>\u2212</sup> in synthetic sea water from 273.15 to 318.15 K. Journal of Chemical Thermodynamics 22, 113\u2013127. doi:10.1016/0021-9614(90)90074-Z.</p> D90b: Dickson (1990) Deep-Sea Res. Pt. A <p>Dickson, A. G. (1990). Thermodynamics of the dissociation of boric acid in synthetic seawater from 273.15 to 318.15 K. Deep-Sea Research Part A 37, 755\u2013766. doi:10.1016/0198-0149(90)90004-F.</p> DM87: Dickson &amp; Millero (1987) Deep-Sea Res. Pt. A <p>Dickson, A. G., and Millero, F. J. (1987). A comparison of the equilibrium constants for the dissociation of carbonic acid in seawater media. Deep-Sea Research Part A 34, 1733\u20131743. doi:10.1016/0198-0149(87)90021-5.</p> DOE94: DOE (1994) \"Handbook of methods...\" <p>DOE (1994). Handbook of methods for the analysis of the various parameters of the carbon dioxide system in sea water, version 2. ORNL/CDIAC-74.</p> DR79: Dickson &amp; Riley (1979) Mar. Chem. <p>Dickson, A. G., and Riley, J. P. (1979). The estimation of acid dissociation constants in sea-water media from potentiometric titrations with strong base. II. The dissociation of phosphoric acid. Marine Chemistry 7, 101\u2013109. doi:10.1016/0304-4203(79)90002-1.</p>"},{"location":"refs/#e","title":"E","text":"EG70: Edmond &amp; Gieskes (1970) Geochim. Cosmochim. Acta <p>Edmond, J. M., and Gieskes, J. M. T. M. (1970). On the calculation of the degree of saturation of sea water with respect to calcium carbonate under in situ conditions. Geochimica et Cosmochimica Acta 34(12), 1261\u20131291. doi:10.1016/0016-7037(70)90041-4.</p> ESM10: Egleston et al. (2010) Global Biogeochem. Cycles <p>Egleston, E. S., Sabine, C. L., and Morel, F. M. M. (2010). Revelle revisited: Buffer factors that quantify the response of ocean chemistry to changes in DIC and alkalinity. Global Biogeochemical Cycles 24, GB1002. doi:10.1029/2008GB003407.</p>"},{"location":"refs/#f","title":"F","text":"FCG94: Frankignoulle et al. (1994) Limnol. Oceanogr. <p>Frankignoulle, M., Canon, C., and Gattuso, J.-P. (1994). Marine calcification as a source of carbon dioxide: Positive feedback of increasing atmospheric CO<sub>2</sub>. Limnology and Oceanography 39, 458\u2013462. doi:10.4319/lo.1994.39.2.0458.</p>"},{"location":"refs/#g","title":"G","text":"GG46: Goff &amp; Gratch (1946) Trans. Am. Heat. Vent. Eng. <p>Goff, J. A., and Gratch, S. (1946). Low-pressure properties of water from -160 to 212 \u00b0F. Transactions of the American Society of Heating and Ventilating Engineers 52, 95\u2013122.</p> GP89: Goyet &amp; Poisson (1989) Deep-Sea Res. Pt. A <p>Goyet, C., and Poisson, A. (1989). New determination of carbonic acid dissociation constants in seawater as a function of temperature and salinity. Deep-Sea Research Part A 36, 1635\u20131654. doi:10.1016/0198-0149(89)90064-2.</p>"},{"location":"refs/#h","title":"H","text":"H24: Humphreys (2024) Ocean Sci. <p>Humphreys, M. P. (2024).  Temperature effect on seawater \u0192CO<sub>2</sub> revisited: theoretical basis, uncertainty analysis and implications for parameterising carbonic acid equilibrium constants.  Ocean Science 20, 1325-1350.  doi:10.5194/os-20-1325-2024.</p> H73a: Hansson (1973) Deep-Sea Res. <p>Hansson, I. (1973). A new set of acidity constants for carbonic acid and boric acid in sea water. Deep-Sea Research 20, 461\u2013478. doi:10.1016/0011-7471(73)90100-9.</p> H73b: Hansson (1973) Acta Chem. Scand. <p>Hansson, I. (1973). The Determination of Dissociation Constants of Carbonic Acid in Synthetic Sea Water in the Salinity Range of 20\u201340 \u2030 and Temperature Range of 5\u201330\u00b0C. Acta Chemica Scandinavica 27, 931\u2013944. doi:10.3891/acta.chem.scand.27-0931.</p> HDW18: Humphreys et al. (2018) Mar. Chem. <p>Humphreys, M. P., Daniels, C. J., Wolf-Gladrow, D. A., Tyrrell, T., and Achterberg, E. P. (2018). On the influence of marine biogeochemical processes over CO<sub>2</sub> exchange between the atmosphere and ocean. Marine Chemistry 199, 1\u201311. doi:10.1016/j.marchem.2017.12.006.</p> HLSP22: Humphreys et al. (2022) Geosci. Model Dev. <p>Humphreys, M. P., Lewis, E. R., Sharp, J. D., and Pierrot, D. (2021).  PyCO2SYS v1.8: marine carbonate system calculations in Python.  Geoscientific Model Development 15, 15\u201343.  doi:10.5194/gmd-15-15-2022.</p> HSS22: Humphreys et al. (2022) \"PyCO2SYS: marine carbonate...\" <p>Humphreys, M. P., Schiller, A. J., Sandborn, D. E., Gregor, L., Pierrot, D., van Heuven, S. M. A. C., Lewis, E. R., and Wallace, D. W. R. (2022). PyCO2SYS: marine carbonate system calculations in Python.  Zenodo. doi:10.5281/zenodo.3744275.</p> HPR11: van Heuven et al. (2011) \"CO<sub>2</sub>SYS v1.1, MATLAB...\" <p>van Heuven, S., Pierrot, D., Rae, J. W. B., Lewis, E., and Wallace, D. W. R. (2011). CO<sub>2</sub>SYS v 1.1, MATLAB program developed for CO<sub>2</sub> system calculations. ORNL/CDIAC-105b, Carbon Dioxide Information Analysis Center, Oak Ridge National Laboratory, U.S. Department of Energy, Oak Ridge, TN, USA. doi:10.3334/CDIAC/otg.CO2SYS_MATLAB_v1.1.</p>"},{"location":"refs/#i","title":"I","text":"I75: Ingle (1975) Mar. Chem. <p>Ingle, S. E. (1975). Solubility of calcite in the ocean. Marine Chemistry 3, 301\u2013319. doi:10.1016/0304-4203(75)90010-9.</p> ICHP73: Ingle et al. (1973) Mar. Chem. <p>Ingle, S. E., Culberson, C. H., Hawley, J. E., and Pytkowicz, R. M. (1973). The solubility of calcite in seawater at atmospheric pressure and 35\u2030 salinity. Marine Chemistry 1, 295\u2013307. doi:10.1016/0304-4203(73)90019-4.</p>"},{"location":"refs/#k","title":"K","text":"KP67: Kester &amp; Pytkowicz (1967) Limnol. Oceanogr. <p>Kester, D. R., and Pytkowicz, R. M. (1967). Determination of the Apparent Dissociation Constants of Phosphoric Acid in Seawater. Limnology and Oceanography 12, 243\u2013252. doi:10.4319/lo.1967.12.2.0243.</p> KRCB77: Khoo et al. (1977) Anal. Chem. <p>Khoo, K. H., Ramette, R. W., Culberson, C. H., and Bates, R. G. (1977). Determination of hydrogen ion concentrations in seawater from 5 to 40C: standard potentials at salinities from 20 to 45 per mille. Analytical Chemistry 49, 29\u201334. doi:10.1021/ac50009a016.</p> KSK18: Kuli\u0144ski et al. (2018) Mar. Chem. <p>Kuli\u0144ski, K., Szymczycha, B., Koziorowska, K., Hammer, K., Schneider, B. (2018). Anomaly of total boron concentration in the brackish waters of the Baltic Sea and its consequence for the CO<sub>2</sub> system calculations. Marine Chemistry 204, 11-19. doi:10.1016/j.marchem.2018.05.007.</p>"},{"location":"refs/#l","title":"L","text":"LDK00: Lueker et al. (2000) Mar. Chem. <p>Lueker, T. J., Dickson, A. G., and Keeling, C. D. (2000). Ocean pCO<sub>2</sub> calculated from dissolved inorganic carbon, alkalinity, and equations for K<sub>1</sub> and K<sub>2</sub>: validation based on laboratory measurements of CO<sub>2</sub> in gas and seawater at equilibrium. Marine Chemistry 70, 105\u2013119. doi:10.1016/S0304-4203(00)00022-0.</p> LKB10: Lee et al. (2010) Geochim. Cosmochim. Acta <p>Lee, K., Kim, T.-W., Byrne, R. H., Millero, F. J., Feely, R. A., and Liu, Y.-M. (2010). The universal ratio of boron to chlorinity for the North Pacific and North Atlantic oceans. Geochimica et Cosmochimica Acta 74, 1801\u20131811. doi:10.1016/j.gca.2009.12.027.</p> LTB69: Li et al. (1969) J. Geophys. Res. <p>Li, Y.-H., Takahashi, T., and Broecker, W. S. (1969). Degree of saturation of CaCO<sub>3</sub> in the oceans. Journal of Geophysical Research 74, 5507\u20135525. doi:10.1029/JC074i023p05507.</p> LW98: Lewis &amp; Wallace (1998) \"Program developed for...\" <p>Lewis, E., and Wallace, D. W. R. (1998). Program Developed for CO<sub>2</sub> System Calculations. ORNL/CDIAC-105, Carbon Dioxide Information Analysis Center, Oak Ridge National Laboratory, U.S. Department of Energy, Oak Ridge, TN, USA.</p>"},{"location":"refs/#m","title":"M","text":"M10: Millero (2010) Mar. Freshwater Res. <p>Millero, F. J. (2010). Carbonate constants for estuarine waters. Marine and Freshwater Research 61(2), 139\u2013142. doi:10.1071/MF09254.</p> M13: Munhoven (2013) Geosci. Model Dev. <p>Munhoven, G. (2013). Mathematics of the total alkalinity\u2013pH equation \u2013 pathway to robust and universal solution algorithms: the SolveSAPHE package v1.0.1. Geoscientific Model Development 6, 1367\u20131388. doi:10.5194/gmd-6-1367-2013.</p> M16: Maclaurin (2016) Autograd: Automatic Differentiation... <p>Maclaurin, D. (2016). \u201cAutograd: Automatic Differentiation for Python,\u201d in Modeling, Inference and Optimization with Composable Differentiable Procedures (PhD thesis, Harvard University, Cambridge, MA), 41\u201357.</p> M79: Millero (1979) Geochim. Cosmochim. Acta <p>Millero, F. J. (1979). The thermodynamics of the carbonate system in seawater. Geochimica et Cosmochimica Acta 43, 1651\u20131661. doi:10.1016/0016-7037(79)90184-4.</p> M83: Mucci (1983) Am. J. Sci. <p>Mucci, A. (1983). The solubility of calcite and aragonite in seawater at various salinities, temperatures, and one atmosphere total pressure. American Journal of Science 283, 780\u2013799. doi:10.2475/ajs.283.7.780.</p> Mi83: Millero (1983) in \"Chemical Oceanography\" <p>Millero, F. J. (1983). \u201cInfluence of pressure on chemical processes in the sea,\u201d in Chemical Oceanography, eds. J. P. Riley and R. Chester (Academic Press).</p> MS92: Millero &amp; Sohn (1992) \"Chemical Oceanography\" <p>Millero, F. J., and Sohn, M. L. (1992). Chemical Oceanography. CRC Press, Florida, USA.</p> M95: Millero (1995) Geochim. Cosmochim. Acta <p>Millero, F. J. (1995). Thermodynamics of the carbon dioxide system in the oceans. Geochimica et Cosmochimica Acta 59, 661\u2013677. doi:10.1016/0016-7037(94)00354-O.</p> MCHP73: Mehrbach et al. (1973) Limnol. Oceanogr. <p>Mehrbach, C., Culberson, C. H., Hawley, J. E., and Pytkowicz, R. M. (1973). Measurement of the Apparent Dissociation Constants of Carbonic Acid in Seawater at Atmospheric Pressure. Limnology and Oceanography 18, 897\u2013907. doi:10.4319/lo.1973.18.6.0897.</p> MGH06: Millero et al. (2006) Mar. Chem. <p>Millero, F. J., Graham, T. B., Huang, F., Bustos-Serrano, H., and Pierrot, D. (2006). Dissociation constants of carbonic acid in seawater as a function of salinity and temperature. Marine Chemistry 100, 80\u201394. doi:10.1016/j.marchem.2005.12.001.</p> MM02: Mojica Prieto &amp; Millero (2002) Geochim. Cosmochim. Acta <p>Mojica Prieto, F. J., and Millero, F. J. (2002). The values of pK<sub>1</sub> + pK<sub>2</sub> for the dissociation of carbonic acid in seawater. Geochimica et Cosmochimica Acta 66, 2529\u20132540. doi:10.1016/S0016-7037(02)00855-4.</p> MPL02: Millero et al. (2002) Deep-Sea Res. Pt. I <p>Millero, F. J., Pierrot, D., Lee, K., Wanninkhof, R., Feely, R., Sabine, C. L., et al. (2002). Dissociation constants for carbonic acid determined from field measurements. Deep-Sea Research Part I 49, 1705\u20131723. doi:10.1016/S0967-0637(02)00093-6.</p> MR66: Morris &amp; Riley (1966) Deep-Sea Res. <p>Morris, A. W., and Riley, J. P. (1966). The bromide/chlorinity and sulphate/chlorinity ratio in sea water. Deep-Sea Research 13, 699\u2013705. doi:10.1016/0011-7471(66)90601-2.</p>"},{"location":"refs/#o","title":"O","text":"OE15: Orr &amp; Epitalon (2015) Geosci. Model Dev. <p>Orr, J. C., and Epitalon, J.-M. (2015). Improved routines to model the ocean carbonate system: mocsy 2.0. Geoscientific Model Development 8, 485\u2013499. doi:10.5194/gmd-8-485-2015.</p> OEG15: Orr et al. (2015) Biogeosciences <p>Orr, J. C., Epitalon, J.-M., and Gattuso, J.-P. (2015). Comparison of ten packages that compute ocean carbonate chemistry. Biogeosciences 12, 1483\u20131510. doi:10.5194/bg-12-1483-2015.</p> OEDG18: Orr et al. (2018) Mar. Chem. <p>Orr, J. C., Epitalon, J.-M., Dickson, A. G., and Gattuso, J.-P. (2018). Routine uncertainty propagation for the marine carbon dioxide system. Marine Chemistry 207, 84\u2013107. doi:10.1016/j.marchem.2018.10.006.</p>"},{"location":"refs/#p","title":"P","text":"PF87: Perez &amp; Fraga (1987) Mar. Chem. <p>Perez, F. F., and Fraga, F. (1987). Association constant of fluoride and hydrogen ions in seawater. Marine Chemistry 21, 161\u2013168. doi:10.1016/0304-4203(87)90036-3.</p> PLR18: Papadimitriou et al. (2018) Geochim. Cosmochim. Acta <p>Papadimitriou, S., Loucaides, S., R\u00e9rolle, V. M. C., Kennedy, P., Achterberg, E. P., Dickson, A. G., Mowlem, M., and Kennedy, H. (2018). The stoichiometric dissociation constants of carbonic acid in seawater brines from 298 to 267 K. Geochimica et Cosmochimica Acta 220, 55\u201370.  doi:10.1016/j.gca.2017.09.037.</p> PTBO87: Peng et al. (1987) Tellus B <p>Peng, T.-H., Takahashi, T., Broecker, W. S., and Olafsson, J. (1987). Seasonal variability of carbon dioxide, nutrients and oxygen in the northern North Atlantic surface water: observations and a model. Tellus B 39, 439\u2013458. doi:10.3402/tellusb.v39i5.15361.</p>"},{"location":"refs/#r","title":"R","text":"R54: Robinson (1954) J. Mar. Biol. Ass. U.K. <p>Robinson, R. A. (1954). The vapour pressure and osmotic equivalence of sea water. Journal of the Marine Biological Association of the United Kingdom 33, 449\u2013455. doi:10.1017/S0025315400008468.</p> R65: Riley (1965) Deep-Sea Res. <p>Riley, J. P. (1965). The occurrence of anomalously high fluoride concentrations in the North Atlantic. Deep-Sea Research 12, 219\u2013220. doi:10.1016/0011-7471(65)90027-6.</p> RAH18: Richier et al. (2018) Glob. Change Biol. <p>Richier, S., Achterberg, E. P., Humphreys, M. P., Poulton, A. J., Suggett, D. J., Tyrrell, T., et al. (2018). Geographical CO<sub>2</sub> sensitivity of phytoplankton correlates with ocean buffer capacity. Global Change Biology 24, 4438\u20134452. doi:10.1111/gcb.14324.</p> RRV93: Roy et al. (1993) Mar. Chem. <p>Roy, R. N., Roy, L. N., Vogel, K. M., Porter-Moore, C., Pearson, T., Good, C. E., et al. (1993). The dissociation constants of carbonic acid in seawater at salinities 5 to 45 and temperatures 0 to 45\u00b0C. Marine Chemistry 44, 249\u2013267. doi:10.1016/0304-4203(93)90207-5.</p> RT67: Riley &amp; Tongudai (1967) Chem. Geol. <p>Riley, J. P., and Tongudai, M. (1967). The major cation/chlorinity ratios in sea water. Chemical Geology 2, 263\u2013269. doi:10.1016/0009-2541(67)90026-5.</p>"},{"location":"refs/#s","title":"S","text":"SB21: Schockman &amp; Byrne (2021) Geochim. Cosmochim. Acta <p>Schockman, K. M., and Byrne, R. H. (2021). Spectrophotometric Determination of the Bicarbonate Dissociation Constant in Seawater. Geochemica Cosmochimica Acta, in press.  doi:10.1016/j.gca.2021.02.008.</p> SLH20: Sulpis et al. (2020) Ocean Sci. <p>Sulpis, O., Lauvset, S. K., and Hagens, M. (2020). Current estimates of K<sub>1</sub><sup>*</sup> and K<sub>2</sub><sup>*</sup> appear inconsistent with measured CO<sub>2</sub> system parameters in cold oceanic regions. Ocean Science 16(4), 847\u2013862. doi:10.5194/os-2020-19.</p> SMB64: Sill\u00e9n et al. (1964) Chem. Soc. London <p>Sill\u00e9n, L. G., Martell, A. E., and Bjerrum, J. (1964). Stability constants of metal-ion complexes. Special Publication 17. London, UK: Chemical Society.</p> SPH20: Sharp et al. (2020) CO2-System-Extd <p>Sharp, J. D., Pierrot, D., Humphreys, M. P., Epitalon, J.-M., Orr, J. C., Lewis, E., Wallace, D. W. R. (2020). CO2-System-Extd, v3.0.  MATLAB (MathWorks).  Available from github.com/jonathansharp/CO2-System-Extd.</p>"},{"location":"refs/#t","title":"T","text":"TOG93: Takahashi et al. (1993) Global Biogeochem. Cycles <p>Takahashi, T., Olafsson, J., Goddard, J. G., Chipman, D. W., and Sutherland, S. C. (1993).  Seasonal variation of CO<sub>2</sub> and nutirents in the high-latitude surface oceans: a comparative study.  Global Biogeochemical Cycles 7(4), 843-878.  doi:10.1029/93GB02263.</p> TSW09: Takahashi et al. (2009) Deep-Sea Res. Pt. II <p>Takahashi, T., Sutherland, S. C., Wanninkhof, R., Sweeney, C., Feely, R. A., Chipman, D. W., Hales, B., Friederich, G., Chavez, F., Sabine, C., Watson, A., Bakker, D. C. E., Schuster, U., Metzl, N., Yoshikawa-Inoue, H., Ishii, M., Midorikawa, T., Nojiri, Y., K\u00f6rtzinger, A., Steinhoff, T., Hoppema, M., Olafsson, J., Arnarson, T. S., Tilbrook, B., Johannessen, T., Olsen, A., Bellerby, R., Wong, C. S., Delille, B., Bates, N. R., and de Baar, H. J. W. (2009).  Climatological mean and decadal change in surface ocean pCO<sub>2</sub>, and net sea-air CO<sub>2</sub> flux over the global oceans.  Deep-Sea Research II 56, 554\u2013577.  doi:10.1016/j.dsr2.2008.12.009.</p> TWB82: Takahashi et al. (1982) in \"GEOSECS Pacific Expedition\" <p>Takahashi, T., Williams, R. T., and Bos, D. L. (1982). \u201cCarbonate Chemistry,\u201d in GEOSECS Pacific Expedition: Hydrographic Data (Washington, D. C.: National Science Foundation), 77\u2013105.</p>"},{"location":"refs/#u","title":"U","text":"U74: Uppstr\u00f6m (1974) Deep-Sea Res. <p>Uppstr\u00f6m, L. R. (1974). The boron/chlorinity ratio of deep-sea water from the Pacific Ocean. Deep-Sea Research 21, 161\u2013162. doi:10.1016/0011-7471(74)90074-6.</p>"},{"location":"refs/#w","title":"W","text":"W74: Weiss (1974) Mar. Chem. <p>Weiss, R. F. (1974). Carbon dioxide in water and seawater: the solubility of a non-ideal gas. Marine Chemistry 2, 203\u2013215. doi:10.1016/0304-4203(74)90015-2.</p> WM13: Waters &amp; Millero (2013) Mar. Chem. <p>Waters, J.F., Millero, F.J. (2013). The free proton concentration scale for seawater pH. Marine Chemistry 149, 8\u201322. doi:10.1016/j.marchem.2012.11.003.</p> WMW14: Waters et al. (2014) Mar. Chem. <p>Waters, J., Millero, F. J., and Woosley, R. J. (2014). Corrigendum to \u201cThe free proton concentration scale for seawater pH\u201d, [MARCHE: 149 (2013) 8\u201322]. Marine Chemistry 165, 66\u201367. doi:10.1016/j.marchem.2014.07.004.</p> WP80: Weiss &amp; Price (1980) Mar. Chem. <p>Weiss, R. F., and Price, B. A. (1980). Nitrous oxide solubility in water and seawater. Marine Chemistry 8, 347\u2013359. doi:10.1016/0304-4203(80)90024-9.</p> WZK07: Wolf-Gladrow et al. (2007) Mar. Chem. <p>Wolf-Gladrow, D. A., Zeebe, R. E., Klaas, C., K\u00f6rtzinger, A., and Dickson, A. G. (2007). Total alkalinity: The explicit conservative expression and its application to biogeochemical processes. Marine Chemistry 106, 287-300. doi:10.1016/j.marchem.2007.01.006.</p>"},{"location":"refs/#y","title":"Y","text":"YM95: Yao &amp; Millero (1995) Aquat. Geochem. <p>Yao, W., and Millero, F. J. (1995). The chemistry of the anoxic waters in the Framvaren Fjord, Norway. Aquatic Geochemistry 1, 53\u201388. doi:10.1007/BF01025231.</p>"},{"location":"refs/#z","title":"Z","text":"ZW01: Zeebe &amp; Wolf-Gladrow (2001) \"CO<sub>2</sub> in Seawater...\" <p>Zeebe, R. E., and Wolf-Gladrow, D. (2001). CO<sub>2</sub> in Seawater: Equilibrium, Kinetics, Isotopes. Elsevier B.V., Amsterdam, the Netherlands.</p>"},{"location":"results/","title":"Advanced results access","text":"<p>The results can be solved for and accessed in several ways.</p> <p>Running the <code>pyco2.sys</code> function performs some conditioning of the arguments (converts <code>int</code> to <code>float</code> and all iterables to NumPy arrays) before passing these into the constructor for a <code>CO2System</code> object, which is returned.  If all arguments are already well-conditioned, then they can be passed directly to <code>PyCO2SYS.CO2System</code>, thus skipping the (minor) extra overhead of <code>pyco2.sys</code>.</p>"},{"location":"results/#as-if-it-were-a-dict","title":"As if it were a dict","text":"<p>First is to treat the <code>CO2System</code> as a dict and access with the keys given in Arguments and results.</p> <pre><code>import PyCO2SYS as pyco2\n\n# Set up the CO2System\nco2s = pyco2.sys(alkalinity=2250, dic=2100)\n\n# Solve for and return pH\npH = co2s[\"pH\"]\n</code></pre> <p>The initial call to <code>pyco2.sys</code> does not solve for any parameters.  The pH value is determined only when it is accessed with <code>co2s[\"pH\"]</code>.  Intermediate parameters (e.g., equilibrium constants) computed along the way are also stored in the <code>CO2System</code> at this point, so a subsequent call to calculate e.g. pCO<sub>2</sub> will use these (and the now-known pH value) instead of repeating those calculations.</p>"},{"location":"results/#multiple-values-at-once","title":"Multiple values at once","text":"<p>We can also return multiple values at once by providing their keys as a list:</p> <pre><code># Solve for and return pH and pCO2\nresults = co2s[[\"pH\", \"pCO2\"]]\n</code></pre> <p>The <code>results</code> are a dict containing the values of pH and pCO<sub>2</sub>.</p>"},{"location":"results/#solve-without-returning","title":"Solve without returning","text":"<p>We can solve for a parameter without returning its value using the <code>solve</code> method.  This gives more control over how intermediate parameters are handled:</p> <pre><code>co2s.solve([\"pH\", \"pCO2\"], store_steps=1)\n</code></pre> <p>The kwarg <code>store_steps</code> allows us to determine which intermediate parameters are stored internally after the calculation is complete.  It can be set to:</p> <ul> <li><code>0</code>: store only the specifically requested parameters.</li> <li><code>1</code>: store the most used set of intermediate parameters (default).</li> <li><code>2</code>: store the complete set of parameters</li> </ul>"},{"location":"uncertainty/","title":"Uncertainty propagation","text":"<p>PyCO2SYS provides tools to propagate uncertainties in all arguments through to all results of its marine carbonate system calculations.  All derivatives needed for uncertainty propagation are calculated with automatic differentiation.</p>"},{"location":"uncertainty/#independent-uncertainties","title":"Independent uncertainties","text":"<p>If the uncertainty in each argument is independent \u2013 i.e. there is no covariance between the uncertainties in different parameters \u2013 then you can use the <code>propagate</code> method to propagate the parameter uncertainties through into any result.</p>"},{"location":"uncertainty/#syntax","title":"Syntax","text":"<p>Uncertainty propagation can be performed with the <code>propagate</code> method, which has the syntax:</p> <pre><code>co2s.propagate(uncertainty_from, uncertainty_into)\n</code></pre> <p>where <code>co2s</code> is a <code>CO2System</code>.</p>"},{"location":"uncertainty/#arguments","title":"Arguments","text":"<ul> <li> <p><code>uncertainty_into</code> is a list of strings of the results keys to propagate uncertainties into.</p> </li> <li> <p><code>uncertainty_from</code> is a dict of the uncertainties in the arguments to propagate through <code>pyco2.sys</code>.</p> </li> </ul> <p>The keys of <code>uncertainty_from</code> can include any <code>CO2System</code> arguments that can have an uncertainty.  The key for each uncertainty in <code>uncertainty_from</code> should be the same as the corresponding key in the <code>CO2System</code> results.</p> <p>Some additional considerations:</p> <ul> <li> <p>To provide a fractional value for any uncertainty, append <code>\"__f\"</code> to the end of its key in <code>uncertainty_from</code>.</p> </li> <li> <p>For the equilibrium constants, to propagate an uncertainty in terms of a pK value rather than K, prefix the corresponding key in <code>uncertainty_from</code> with a <code>\"p\"</code> (e.g. use <code>\"pk_H2CO3\"</code> instead of <code>\"k_H2CO3\"</code>).</p> </li> <li> <p>The \"standard\" uncertainties in the equilbrium constants and total borate used by CO2SYS for MATLAB following OEDG18 are available as a dict in the correct format for <code>uncertainty_from</code> at <code>pyco2.uncertainty_OEDG18</code>.</p> </li> <li> <p>The values of <code>uncertainty_from</code> are the uncertainties in each input parameter as a standard deviation.  You can provide a single value if all uncertainties are the same for a parameter, or an array of the same size as the parameter if they are different.  Any parameters not included are assumed to have zero uncertainty.</p> </li> </ul>"},{"location":"uncertainty/#results","title":"Results","text":"<p>The uncertainty results are added to <code>co2s.uncertainty</code>.</p> <ul> <li> <p>For each result <code>into</code> in <code>uncertainty_into</code>, there is a new sub-dict <code>co2s.uncertainty[into]</code> containing the total and component uncertainties in that result.</p> </li> <li> <p>The total uncertainty is in <code>co2s.uncertainty[into][\"total\"]</code>.</p> </li> <li> <p>The uncertainties from each argument <code>from</code> in <code>uncertainty_from</code> are also in the sub-dict with the corresponding keys: <code>co2s.uncertainty[into][from]</code>.</p> </li> </ul> <p>The total uncertainties are the Pythagorean sum of all the components.  This calculation assumes that all argument uncertainties are independent from each other and that they are provided in terms of single standard deviations.</p>"},{"location":"uncertainty/#example-calculation","title":"Example calculation","text":"<p>An example calculation, explained below:</p> <pre><code>import PyCO2SYS as pyco2\n\n# Set up the CO2System\nco2s = pyco2.sys(\n    alkalinity=2250,\n    pH=8.1,\n    temperature=12.5,\n    salinity=32.4,\n    opt_k_carbonic=10,\n)\n\n# Propagate uncertainties\nco2s.propagate(\n    [\"dic\", \"fCO2\"],\n    {\n        \"alkalinity\": 2,\n        \"pH\": 0.02,\n        \"pk_H2O\": 0.01,\n    }\n)\n\n# Access propagated uncertainties\ndic_uncertainty = co2s.uncertainty[\"dic\"][\"total\"]\nfCO2_uncertainty_from_pH = co2s.uncertainty[\"fCO2\"][\"pH\"]\n</code></pre> <p>Above, we propagated independent uncertainties in alkalinity (<code>alkalinity</code>; 2\u00a0\u00b5mol\u00a0kg<sup>\u20131</sup>), pH (<code>pH</code>, 0.02) and pK*(H<sub>2</sub>O) (<code>pk_H2O</code>; 0.01) through to DIC (<code>dic</code>) and fCO<sub>2</sub> (<code>fCO2</code>).</p> <p>The results of the propagation can be accessed in the <code>co2s.uncertainty</code> dict, which includes both individual component contributions to the final uncertainty (e.g., <code>co2s.uncertainty[\"fCO2\"][\"pH\"]</code>) as well as the total uncertainty calculated assuming the components are independent (e.g., <code>co2s.uncertainty[\"dic\"][\"total\"]</code>).</p>"},{"location":"uncertainty/#uncertainties-with-covariances","title":"Uncertainties with covariances","text":"<p>PyCO2SYS does not currently have a generalised function for the complete process of propagating uncertainties that co-vary.  However, it does allow you calculate the derivative of any result with respect to any argument.  The syntax is similar as described above for uncertainties:</p> <pre><code>co2s.get_grads(grads_of, grads_wrt)\n</code></pre> <p>In general, this works the same as the uncertainty propagation approach described in the previous section.  The main differences are:</p> <ul> <li><code>grads_of</code> is equivalent to <code>uncertainty_into</code>.</li> <li><code>grads_wrt</code> (w.r.t. = with respect to) is equivalent to <code>uncertainty_from</code>, but values are not required, so it can be a list.  A dict is also fine; its values are ignored.</li> <li>The <code>\"__f\"</code> key extension cannot be used in <code>grads_wrt</code>.</li> <li>For each result <code>of</code> in <code>grads_of</code> and argument <code>wrt</code> in <code>grads_wrt</code>, the corresponding derivative is added to <code>co2s.grads[of][wrt]</code>.</li> </ul>"},{"location":"v1_to_v2/","title":"Switching from v1 to v2","text":"<p>This explanation is designed as a detailed overview of differences for those who are already familiar with using PyCO2SYS with the <code>pyco2.sys</code> syntax from v1.  New or casual users may find the general instructions for v2 more helpful.</p>"},{"location":"v1_to_v2/#solving-the-carbonate-system","title":"Solving the carbonate system","text":"<p>On the surface, v2 looks similar to v1.  For example:</p> v2.0v1.8 <pre><code>import PyCO2SYS as pyco2\n\n# Set up the CO2System\nco2s = pyco2.sys(\n    alkalinity=2250,\n    pH=8.1,\n    temperature=12.5,\n    salinity=32.4,\n    opt_k_carbonic=10,\n)\n# Solve for and retrieve a calculated parameter\ndic = co2s[\"dic\"]\n</code></pre> <pre><code>import PyCO2SYS as pyco2\n\n# Solve the carbonate system\nco2s = pyco2.sys(\n    par1=2250,\n    par2=8.1,\n    par1_type=1,\n    par2_type=2,\n    temperature=12.5,\n    salinity=32.4,\n    opt_k_carbonic=10,\n)\n# Retrieve a calculated parameter\ndic = co2s[\"dic\"]\n</code></pre>"},{"location":"v1_to_v2/#one-set-of-settings-per-call","title":"One set of settings per call","text":"<p>The most obvious change above is that the known marine carbonate system parameters <code>alkalinity</code> and <code>pH</code> are provided directly as kwargs, instead of using the old approach with <code>par1</code>, <code>par2</code>, <code>par1_type</code> and <code>par2_type</code>.</p> <p>This does mean that it's no longer possible to have multiple different parameter types within a single call to <code>pyco2.sys</code>.  Similarly, all settings parameters (anything beginning with <code>opt_</code>) can no longer be provided as arrays \u2013 each call to <code>pyco2.sys</code> can only have one combination of settings.</p> <p>However, as before, all other parameters (e.g., <code>alkalinity</code>, <code>pH</code>, <code>temperature</code> and <code>salinity</code>) can be scalars or NumPy arrays of any shape, as long as they can all be broadcasted together.</p> <p>Also as before, it's possible to provide no carbonate system parameters, and just calculate equilibrium constants and total salt contents, or one carbonate system parameter, and do whatever calculations are possible with it alone.</p>"},{"location":"v1_to_v2/#when-the-system-is-solved","title":"When the system is solved","text":"<p>In v1.8, the result <code>co2s</code> was a standard Python dict containing all possible parameters, which were computed at the moment that <code>pyco2.sys</code> was called.  However, in v2.0, <code>co2s</code> is a <code>CO2System</code> object, and it contains only the values of kwargs provided as arguments.  Other parameters are computed only when the user attempts to retrieve them (e.g., with <code>co2s[\"dic\"]</code> above).</p> <p>When a parameter is retrieved, the minimum set of intermediate parameters required to compute it are also calculated and stored in <code>co2s</code>.  These stored values will be used to compute any subsequently requested parameters \u2013 they will not be recomputed each time.</p>"},{"location":"v1_to_v2/#retrieving-parameters","title":"Retrieving parameters","text":"<p>As mentioned above, parameters can be retrieved (and, if necessary, calculated) as if <code>co2s</code> were a standard Python dict.  However, there is also more flexibility:</p>"},{"location":"v1_to_v2/#retrieving-multiple-parameters","title":"Retrieving multiple parameters","text":"<p>A list of parameters can be provided with the same syntax as above:</p> v2.0 <pre><code># Solve for / return DIC and fCO2\nparams = co2s[[\"dic\", \"fCO2\"]]\n\n# Access the results\ndic = params[\"dic\"]\nfCO2 = params[\"fCO2\"]\n</code></pre> <p>The result <code>params</code> is a standard dict containing the requested parameters.</p>"},{"location":"v1_to_v2/#the-solve-method","title":"The <code>solve</code> method","text":"<p>Parameters can be solved for using <code>solve</code>:</p> v2.0 <pre><code># Solve for a calculated parameter\nco2s.solve(\"dic\", store_steps=1)\n</code></pre> <p>This gives the added flexibility of the <code>store_steps</code> kwarg:</p> <ul> <li>If <code>0</code>, then only the requested parameter is stored.</li> <li>If <code>1</code> (default), then the standard set of intermediate parameters is stored in the <code>co2s</code>.</li> <li>If <code>2</code>, then all possible intermediate parameters are stored.</li> </ul>"},{"location":"v1_to_v2/#dot-notation","title":"Dot notation","text":"<p>If a parameter has been calculated, either directly or as an intermediate for another parameter, and its value is stored in the <code>co2s</code>, it can also be accessed with dot notation:</p> v2.0 <pre><code># Access DIC, if it has been previously calculated\ndic = co2s.dic\n</code></pre> <p>This will throw an error if the requested parameter is not already available.</p>"},{"location":"v1_to_v2/#input-and-output-conditions","title":"Input and output conditions","text":"<p>In v1, a second set of temperature and/or pressure conditions could be specified as 'output' conditions with the suffix <code>_out</code> for their arguments and results.  In v2, each <code>CO2System</code> can only have one set of temperature and pressure conditions.  To adjust to a different set of conditions, use the <code>adjust</code> method:</p> v2.0v1.8 <pre><code># Set up the CO2System\nco2s = pyco2.sys(\n    alkalinity=2250,\n    pH=8.1,\n    temperature=12.5,\n    salinity=32.4,\n    opt_k_carbonic=10,\n)\n\n# Convert to different conditions\nco2s_adj = co2s.adjust(\n    temperature=25,\n    pressure=1000,\n    store_steps=1,\n    method_fCO2=1,\n    opt_which_fCO2_insitu=1,\n    bh_upsilon=None,\n)\n\n# Get fCO2 at the adjusted conditions\nfCO2_adj = co2s_adj[\"fCO2\"]\n</code></pre> <pre><code># Solve the carbonate system\nco2s = pyco2.sys(\n    par1=2250,\n    par2=8.1,\n    par1_type=1,\n    par2_type=2,\n    temperature=12.5,\n    temperature_out=25,\n    pressure_out=1000,\n    salinity=32.4,\n    opt_k_carbonic=10,\n)\n\n# Get fCO2 at the adjusted conditions\nfCO2_adj = co2s[\"fCO2_out\"]\n</code></pre> <p>The result <code>co2s_adj</code> is a separate <code>CO2System</code> at the requested temperature and pressure.  If the original <code>co2s</code> had two known parameters, then both are used to make the adjustment (via DIC and alkalinity).  Temperature can also be adjusted with only one known parameter, if its one of pCO<sub>2</sub>, fCO<sub>2</sub>, [CO<sub>2</sub>(aq)] or xCO<sub>2</sub>.  The kwargs <code>method_fCO2</code>, <code>opt_which_fCO2_insitu</code> and <code>bh_upsilon</code> allow for finer control of the one-parameter adjustment (see the v2 general instructions for details).</p>"},{"location":"v1_to_v2/#uncertainty-propagation","title":"Uncertainty propagation","text":"<p>There are three main differences regarding uncertainty propagation:</p> <ol> <li> <p>Uncertainty propagation is carried out by using the <code>propagate</code> method in v2.0, instead of by including <code>uncertainty_into</code> and <code>uncertainty_from</code> kwargs in the main <code>pyco2.sys</code> call. </p> </li> <li> <p>Uncertainty results are stored in nested dicts in <code>co2s.uncertainty</code> in v2.0, instead of as additional key-value pairs in <code>co2s</code> as in v1.8.</p> </li> <li> <p>The derivatives used to propagate uncertainties are calculated with automatic differentiation in v2.0, but with forward finite differences in v1.8.</p> </li> </ol> <p>The arguments provided to the <code>propagate</code> method in v2.0 are exactly the same <code>uncertainty_into</code> and <code>uncertainty_from</code> as were provided directly to <code>pyco2.sys</code> in v1.8.</p> <p>An example:</p> v2.0v1.8 <pre><code># Set up the CO2System\nco2s = pyco2.sys(\n    alkalinity=2250,\n    pH=8.1,\n    temperature=12.5,\n    salinity=32.4,\n    opt_k_carbonic=10,\n)\n\n# Propagate uncertainties\nco2s.propagate(\"dic\", {\"alkalinity\": 2.1, \"pH\": 0.02})\n\n# Retrieve uncertainties and their components\ndic_uncertainty = co2s.uncertainty[\"dic\"][\"total\"]\ndic_uncertainty_from_pH = co2s.uncertainty[\"dic\"][\"pH\"]\n</code></pre> <pre><code># Solve the carbonate system and propagate uncertainties\nco2s = pyco2.sys(\n    par1=2250,\n    par2=8.1,\n    par1_type=1,\n    par2_type=2,\n    temperature=12.5,\n    salinity=32.4,\n    opt_k_carbonic=10,\n    uncertainty_into=\"dic\",\n    uncertainty_from={\"par1\": 2.1, \"par2\": 0.02},\n)\n\n# Retrieve uncertainties and their components\ndic_uncertainty = co2s[\"u_dic\"]\ndic_uncertainty_from_pH = co2s[\"u_dic__pH\"]\n</code></pre>"},{"location":"v1_to_v2/#settings","title":"Settings","text":"<p>Before v2, changing <code>opt_k_carbonic</code> to a different set of carbonic acid dissociation constants could also cause other parameterisations to be switched behind the scenes (for e.g. the borate equilibrium constant and some pressure correction factors).  This behaviour was inherited from CO2SYS-MATLAB, but it has been eliminated in PyCO2SYS v2.  Instead, every parameterisation that has multiple options is controlled independently with its own setting.</p> <p>This affects only <code>opt_k_carbonic</code> values <code>6</code>, <code>7</code>, and <code>8</code>, i.e., the GEOSECS and freshwater cases.  All other <code>opt_k_carbonic</code> options used the set of parameterisations that are now the defaults in v2.</p>"},{"location":"versions/","title":"Version history","text":"<p>Semantics</p> <p>Version numbering aims to follow semantic versioning. Therefore:</p> <ul> <li>New patch versions (e.g. 1.1.0 to 1.1.1) make minor changes that do not alter fuctionality or calculated results.</li> <li>New minor versions (e.g. 1.0.1 to 1.1.0) add new functionality, but will not break your code.  They will not alter the results of calculations with default settings (except for in the hopefully rare case of correcting a bug or typo).</li> <li>New major versions (e.g. 1.1.1 to 2.0.0) may break your code and require you to rewrite things.  They may significantly alter the results of calculations with default settings.</li> </ul> <p>We will always add aliases for existing functions if their API is updated, to avoid unforseen breaking changes wherever possible.</p> <p>Warning</p> <p>Will (not) break your code refers only to the functions covered in this documentation.</p> <p>For the main CO2SYS function as imported with</p> <pre><code>import PyCO2SYS as pyco2\n\nco2s = pyco2.sys(**kwargs)\n</code></pre> <p>the only things that may change, in at least a minor version release, are:</p> <ol> <li>Additional inputs may be added to the <code>kwargs</code>, but always with default values such that the results do not change if they are not explicitly set.</li> <li>Additional calculated variables may be returned in the output <code>results</code>.</li> </ol> <p>The structure of the underlying modules and their functions is not yet totally stable and, for now, may change in any version increment.  Such changes will be described in the release notes below.</p>"},{"location":"versions/#20-forthcoming","title":"2.0 (forthcoming)","text":"<p>Switches from Autograd to JAX for automatic differentiation.  Internal mechanism rebuilt for significantly more memory-efficient and faster calculations.</p> <p>Changes in v2.0</p> <ul> <li>Calculations performed only when needed for specifically requested parameters.</li> <li>Only one combination of known marine carbonate system parameters allowed per calculation.</li> <li>Only one combination of optional settings allowed per calculation.</li> <li>Optional settings each only affect one parameterisation, so there are more of them.  (In v1, <code>opt_k_carbonic</code> could alter several other parameterisations beyond just the carbonic acid equilibrium.)</li> <li>\"Input\" and \"output\" conditions deprecated in favour of the <code>adjust</code> method.</li> <li>Uncertainty propagation uses automatic differentiation instead of finite differences.</li> <li>Simple tests suggest calculations including iterative pH solving are on the order of 100 times faster and have about 100 times lower peak memory demand.</li> <li>Differences in calculated values from v1.8 should all be at the level of computer precision (i.e., negligible).</li> </ul>"},{"location":"versions/#18","title":"1.8","text":"<p>Adds atmospheric pressure input for pCO<sub>2</sub>-fCO<sub>2</sub>-xCO<sub>2</sub> interconversions and (from v1.8.2) optional hydrostatic pressure effect on CO<sub>2</sub> solubility and fugacity.  Uncertainty analysis updated for more reproducible results.  Rigorously validated and fully documented in peer-reviewed journal article (Humphreys et al., 2022).</p>"},{"location":"versions/#183-16-february-2024","title":"1.8.3 (16 February 2024)","text":"<p>Changes in v1.8.3</p> <p>New features</p> <ul> <li>Added <code>\"dlnfCO2_dT\"</code> and <code>\"dlnpCO2_dT\"</code> results, the theoretical effect of temperature on the natural log of \u0192CO<sub>2</sub> and pCO<sub>2</sub>.</li> <li>Added the PLR18 parameterisation of the carbonic acid constants for sea-ice brines.</li> </ul> <p>Default options</p> <ul> <li>Reverted default <code>opt_k_carbonic</code> to <code>10</code> (i.e., LDK00) for consistency with the best practice guide.</li> </ul> <p>Bug fixes</p> <ul> <li>Updated <code>pyco2.equilibria.p1atm.kH2CO3_NBS_MCHP73</code> (used for <code>opt_k_carbonic</code> options <code>6</code> and <code>7</code>) to update any salinity values less than 10<sup>\u201316</sup> to be 10<sup>\u201316</sup>, because zero salinities give a NaN for K<sub>2</sub>, which causes problems for Autograd.  This should not make any practical difference, because the parameterisation is only valid for salinities above 19.</li> <li>Added <code>opt_pressured_kCO2</code> to results dict and incorporated it correctly into the uncertainty propagation functions.</li> </ul> <p>Technical</p> <ul> <li>Updated from building with setup.py to pyproject.toml.</li> <li>PyCO2SYS can now be installed with conda/mamba (via conda-forge).</li> </ul>"},{"location":"versions/#182-19-january-2023","title":"1.8.2 (19 January 2023)","text":"<p>Changes in v1.8.2</p> <p>New features</p> <ul> <li>Added <code>opt_pressured_kCO2</code> to enable pressure corrections for the fugacity factor and CO<sub>2</sub> solubility constant following W74.  These have been added to CO2SYS-MATLAB by Jon Sharp at the same time with consistent results (differences less than 10<sup>\u22124</sup> %).  These pressure corrections are not enabled by default, for consistency with previous versions.</li> </ul> <p>Bug fixes</p> <ul> <li>Fixed logicals in <code>solve.core()</code> that had meant no results were returned for parameter type combinations <code>7, 10</code>, <code>7, 11</code>, <code>8, 10</code> and <code>8, 11</code>.</li> <li>Updated Autograd version for compatibility with Python 3.11.</li> </ul>"},{"location":"versions/#181-18-may-2022","title":"1.8.1 (18 May 2022)","text":"<p>Changes in v1.8.1</p> <p>Breaking changes</p> <ul> <li>For consistency with other settings, <code>buffers_mode</code> kwarg key changed to <code>opt_buffers_mode</code> and its values are now integers rather than strings.</li> </ul> <p>New features</p> <ul> <li>Adds new <code>par1_type</code> / <code>par2_type</code> options <code>10</code> and <code>11</code> for saturation states with respect to calcite and aragonite.</li> <li>Adds KSK18 parameterisation for estimating total borate from salinity.</li> </ul> <p>Dependencies</p> <ul> <li>Switched to Autograd v1.4.</li> </ul>"},{"location":"versions/#180-27-october-2021","title":"1.8.0 (27 October 2021)","text":"<p>Changes in v1.8.0</p> <p>New features</p> <ul> <li>Adds <code>pressure_atmosphere</code> and <code>pressure_atmosphere_out</code> arguments, rather than assuming 1 atm total barometric pressure.</li> </ul> <p>Behind-the-scenes improvements</p> <ul> <li>Adds additional constraint to the initial pH estimate for more robust results for the alkalinity-CO<sub>2</sub> fugacity parameter pair.</li> <li>Difference derivatives for uncertainties now have a fixed step size for each argument, instead of scaling depending on arguments, for more reproducible results.</li> </ul>"},{"location":"versions/#17","title":"1.7","text":"<p>Adds new syntax to return equilibrium constants and total salts without needing to solve the full carbonate system.  Fully documented in manuscript in review (Humphreys et al., 2021, Geosci. Model Dev. Discuss.).</p>"},{"location":"versions/#171-10-august-2021","title":"1.7.1 (10 August 2021)","text":"<p>Changes in v1.7.1</p> <p>Bug fixes</p> <ul> <li>Improved handling of zero-valued inputs.</li> <li>Adjusted <code>CO2SYS_wrap</code> to work with latest pandas release.</li> </ul>"},{"location":"versions/#170-13-may-2021","title":"1.7.0 (13 May 2021)","text":"<p>Changes in v1.7.0</p> <p>New features</p> <ul> <li>Can now run <code>pyco2.sys</code> with no carbonate system parameter arguments provided, to just return all the equilibrium constants etc. under the specified conditions.</li> <li>Can also run <code>pyco2.sys</code> with only one carbonate system parameter argument.  This does not solve the carbonate system, but does calculate all that can be calculated with that parameter.</li> <li>Added carbonic acid constants parameterisation of SB21.</li> <li>Added bisulfate dissociation constant parameterisation of WM13/WMW14.</li> <li>Added spreadsheet-to-spreadsheet function <code>pyco2.ezio</code> (with thanks to Daniel Sandborn).</li> <li>Integrated uncertainty propagation into the main <code>pyco2.sys</code> function and expanded its capabilities.</li> </ul> <p>Internal updates</p> <ul> <li>Switched default first-guess pH for solving from the alkalinity-carbonate ion parameter pair at low alkalinity from 10 to 3.</li> <li>Renamed various internal functions and variables for better consistency with the Pythonic <code>pyco2.sys</code> i/o syntax.</li> <li>Removed the <code>PyCO2SYS.test</code> module, instead defining the round-robin test functions it contained directly in the test suite.</li> <li>Added various internal settings for testing and validation against older CO2SYS-MATLAB versions.</li> <li>Adjust aqueous CO<sub>2</sub> calculation for better consistency with CO2SYS-MATLAB (but negligible changes in the results).</li> <li>Can now use <code>PyCO2SYS.hello()</code> to find version number and credits (alias for <code>PyCO2SYS.say_hello()</code>).</li> <li>The final component of DIC (or DIC itself) to be calculated is now always computed by difference from the known components.</li> <li>Various functions in <code>convert</code> module renamed.</li> </ul> <p>Validation</p> <ul> <li>Rigorous validation against various CO2SYS-MATLAB versions performed, as described in forthcoming PyCO2SYS manuscript (Humphreys et al., in prep.).</li> </ul> <p>Bug fixes</p> <ul> <li><code>par1</code>, <code>par2</code>, <code>par1_type</code> and <code>par2_type</code> arguments now always get broadcasted to the maximum size, even if they are scalar.</li> <li>Erroneous <code>\"k_phosphate_*\"</code> keys corrected to <code>\"k_phosphoric_\"</code>.</li> <li>Override values for equilibrium constants under output conditions now assigned correctly.</li> <li>Fixed minor errors in initial pH estimates when solving from alkalinity and either DIC or [CO_2(aq)].</li> </ul>"},{"location":"versions/#16","title":"1.6","text":"<p>Adds extra alkalinity components with arbitrary pK values.</p>"},{"location":"versions/#160-26-october-2020","title":"1.6.0 (26 October 2020)","text":"<p>Changes in v1.6.0</p> <p>Bug fixes</p> <ul> <li>Updates the total alkalinity equation to fix minor error in pH scale conversions inherited from CO2SYS-MATLAB (see related note in v1.5.0 release notes).</li> </ul> <p>New inputs and outputs</p> <ul> <li>Enables inputting total molalities and equilibrium constants for up to two additional contributors to total alkalinity.</li> <li>Full chemical speciation returned in the output dict of <code>pyco2.sys</code>, not just the alkalinity components as before.</li> </ul> <p>New syntax</p> <ul> <li>Adds <code>sys</code> as an alias for <code>CO2SYS_nd</code> at the top level.  Recommended Python-style syntax is thus now <code>pyco2.sys</code>.</li> </ul>"},{"location":"versions/#15","title":"1.5","text":"<p>Introduces a more Pythonic top-level function that accepts multidimensional arguments and that only returns results at \"output\" conditions if explicitly specified.</p>"},{"location":"versions/#151-30-july-2020","title":"1.5.1 (30 July 2020)","text":"<p>Changes in v1.5.1</p> <p>Bug fixes</p> <ul> <li>Switched <code>dx</code>-scaling function in <code>PyCO2SYS.uncertainties</code> to use <code>numpy.nanmedian</code> instead of <code>numpy.median</code>.</li> <li>Fixed <code>PyCO2SYS.uncertainties.propagate_nd</code> bug that prevented calculations on non-scalar arguments.</li> </ul>"},{"location":"versions/#150-29-july-2020","title":"1.5.0 (29 July 2020)","text":"<p>Changes in v1.5.0</p> <p>New top-level functions</p> <ul> <li>Adds <code>PyCO2SYS.CO2SYS_nd</code> top-level function with a more Pythonic interface and with NumPy broadcasting of n-dimensional inputs.</li> <li>In <code>PyCO2SYS.CO2SYS_nd</code>, results at \"output\" conditions are only calculated if output temperature or pressure is provided.</li> <li>Adds corresponding <code>PyCO2SYS.uncertainty.forward_nd</code> and <code>PyCO2SYS.uncertainty.propagate_nd</code> functions for uncertainty propagation.</li> </ul> <p>Alternative calculations</p> <ul> <li>New alkalinity equation fixing pH scale conversion bug inherited from CO2SYS-MATLAB is available, but not yet implemented by default.</li> </ul> <p>Extra arguments and results</p> <ul> <li>Solubility constants for aragonite and calcite available directly as outputs from <code>PyCO2SYS.CO2SYS</code> and <code>PyCO2SYS.CO2SYS_nd</code></li> <li>Explicit values for the solubility constants can be given as arguments to override the default internal calculation.</li> </ul> <p>Internal reorganisation</p> <ul> <li>All 2-to-3 functions in <code>PyCO2SYS.solve.get</code> now have a more consistent set of inputs.</li> <li>Revised pH scale conversion functions for consistency and added tests for their internal accuracy.</li> <li>Switched preallocations to use <code>np.shape</code> not <code>np.size</code> in preparation for working with n-dimensional inputs.</li> <li>Updated style to import the whole NumPy module as <code>np</code> instead of individual functions separately.</li> <li>Converted <code>PyCO2SYS.engine</code> to a sub-module.</li> </ul>"},{"location":"versions/#14","title":"1.4","text":"<p>Enables uncertainty propagation with forward finite-difference derivatives.</p>"},{"location":"versions/#143-16-july-2020","title":"1.4.3 (16 July 2020)","text":"<p>Changes in v1.4.3</p> <p>Bug fixes</p> <ul> <li>Corrected missing a pH scale conversion in SLH20 option for carbonic acid dissociation.  Any calculations with this option in PyCO2SYS v1.4.1 or v1.4.2 should be updated!</li> </ul> <p>Validation</p> <ul> <li>Results validated against new release candidate version of CO2SYS-MATLAB v3.</li> </ul> <p>New API</p> <ul> <li>New wrapper function with the same input order and default gas constant option as the new CO2SYS-MATLAB v3 available in <code>PyCO2SYS.api.CO2SYS_MATLABv3</code>.</li> </ul> <p>Internal reorganisation</p> <ul> <li><code>_approx</code> function inputs in <code>PyCO2SYS.solve.delta</code> updated to match the exact Autograd functions for easier switching.</li> </ul>"},{"location":"versions/#142-9-july-2020","title":"1.4.2 (9 July 2020)","text":"<p>Changes in v1.4.2</p> <p>Bug fixes</p> <ul> <li>Swapped order of <code>totals</code> and <code>Ks</code> arguments for all functions in <code>PyCO2SYS.solve.delta</code> for consistency with other modules.</li> <li>Inverted the alkalinity-pH residual equations in <code>PyCO2SYS.solve.delta</code>.</li> </ul> <p>Reorganisation</p> <ul> <li>Broke out some parts of <code>PyCO2SYS.equilibria.assemble</code> into separate functions.</li> </ul>"},{"location":"versions/#141-1-july-2020","title":"1.4.1 (1 July 2020)","text":"<p>Changes in v1.4.1</p> <p>Extra calculation options</p> <ul> <li>Added the 2018 CODATA value for the universal gas constant R as an option for consistency with forthcoming CO2SYS-MATLAB v3.  The original DOEv2 version remains default.</li> <li>Added the SLH20 equations as option <code>16</code> for the carbonic acid dissociation constants.</li> </ul>"},{"location":"versions/#140-9-june-2020","title":"1.4.0 (9 June 2020)","text":"<p>Changes in v1.4.0</p> <p>New features</p> <ul> <li>Added <code>uncertainty</code> module with functions to evaluate derivatives of PyCO2SYS outputs with respect to inputs, along with corresponding documentation.</li> <li>Specific input values can optionally be provided for all total concentrations and equilibrium constants that are estimated internally from salinity, temperature and pressure.</li> </ul> <p>General improvements</p> <ul> <li>Added basic sanity checking to prevent some invalid marine carbonate system parameter input values.</li> <li>Nutrient concentrations have always been set to zero internally for <code>K1K2CONSTANTS</code> options <code>6</code> and <code>8</code>, and salinity too for <code>8</code>, regardless of the input values.  This is now reflected in the output values of these variables in the <code>CO2dict</code>.</li> </ul> <p>New outputs</p> <ul> <li>Substrate:inhibitor ratio (SIR) of B15, calculated with <code>SIratio</code> in new module <code>bio</code>.</li> <li>Inputs <code>PAR1</code> and <code>PAR2</code>.</li> <li>The \"Peng correction\" factor.</li> <li>The fugacity factor for converting between CO<sub>2</sub> partial pressure and fugacity.</li> <li>The activity coefficient of the H<sup>+</sup> ion for NBS pH scale conversions.</li> </ul> <p>Validation</p> <ul> <li>Calculations compare very favourably against the forthcoming CO2SYS for MATLAB v3.</li> </ul>"},{"location":"versions/#13","title":"1.3","text":"<p>Adds bicarbonate ion and aqueous CO<sub>2</sub> as inputs from which the carbonate system can be solved.  Continues to reorganise code behind the scenes.  Makes almost everything Autograd-able and uses this approach to calculate buffer constants.  Validates results against CO2SYS for MATLAB.</p>"},{"location":"versions/#130-1-may-2020","title":"1.3.0 (1 May 2020)","text":"<p>Changes in v1.3.0</p> <p>New features</p> <ul> <li>Added bicarbonate ion (type <code>7</code>) and aqueous CO<sub>2</sub> (type <code>8</code>) as options for known input marine carbonate system variables.</li> <li>Added module <code>test</code> with functions to perform internal consistency checks on <code>PyCO2SYS.CO2SYS</code> calculations and compare results with those from other sources.</li> <li>Added module <code>api</code> with a wrapper for <code>PyCO2SYS.CO2SYS</code> to allow inputs as Pandas Series and/or Xarray DataArrays.</li> </ul> <p>Improved calculations</p> <ul> <li>The Revelle factor and all other buffer factors added in v1.2 are now evaluated using automatic differentiation, which means that the effects of all equilibrating species are taken into account.<ul> <li>The original, non-automatic functions that do not account for nutrient effects are still available in <code>buffers.explicit</code>.</li> <li>Can switch between calculation methods using new optional input <code>opt_buffers_mode</code>.</li> </ul> </li> <li>Corrected Revelle factor calculations:<ul> <li>Added missing \"Peng correction\" to Revelle factor calculation at output conditions.  Note that this correction is currently also missing from CO2SYS for MATLAB!</li> <li>Decreased DIC perturbation size for more accurate finite-difference \"explicit\" evaluation.</li> <li>Finite-difference calculation now references the correct DIC value.</li> </ul> </li> <li>Implemented better initial guesses for pH in all iterative solvers in <code>solve.get</code> following M13 and OE15.</li> <li>Switched to using exact slopes in iterative solvers in <code>solve.get</code>, evaluated using Autograd in new submodule <code>solve.delta</code>.</li> <li>Updated entire package to be Autograd-able.</li> <li>Return NaN instead of negative DIC if an impossible pH-alkalinity combination is given as input (i.e. pH is too high).</li> <li>Return NaN where DIC and one of its components is given if the component is impossibly large.</li> </ul> <p>Internal reorganisation</p> <ul> <li>Major internal reorganisation that is probably not fully captured in these notes.</li> <li>Renamed modules:<ul> <li><code>assemble</code> is now <code>engine</code>.</li> <li><code>concentrations</code> is now <code>salts</code>.</li> <li><code>extra</code> is now <code>buffers.explicit</code>.</li> </ul> </li> <li>Module <code>equilibria</code> now contains sub-modules:<ul> <li><code>p1atm</code> for calculating constants at atmospheric pressure.</li> <li><code>pcx</code> for determining pressure correction factors.</li> <li><code>pressured</code> for calculating constants at given pressure.</li> </ul> </li> <li>Module <code>solve</code> now contains sub-modules:<ul> <li><code>initialise</code> to generate first-guess estimates of pH for the TA-pH solvers.</li> <li><code>get</code> to calculate a new system variable from various input pairs.</li> </ul> </li> <li>Added module <code>solubility</code> for mineral solubility calculations.</li> <li>Relocated <code>_CaSolubility</code> function from root to <code>solubility.CaCO3</code>.<ul> <li>Separated out its internal calculations into a set of subfunctions also in the <code>solubility</code> module.</li> <li>Added calcium molinity <code>TCa</code> as an input, instead of being evaluated internally.</li> </ul> </li> <li>Added calcium molininty <code>TCa</code> (estimated from salinity) into the main <code>CO2dict</code> output from <code>PyCO2SYS.CO2SYS</code>.</li> <li>Relocated <code>_RevelleFactor</code> function from root to <code>buffers.RevelleFactor</code>.</li> <li>Relocated <code>_FindpHOnAllScales</code> function from root to <code>convert.pH2allscales</code>.</li> <li>Added module <code>constants</code> for storing values of universal physical constants.</li> <li>Lists of equilibrium constants and total concentrations now passed around internally as dicts, for safety.</li> <li>Total sulfate and bisulfate dissociation constant renamed from <code>TS</code> and <code>KS</code> to <code>TSO4</code> and <code>KSO4</code> internally to avoid confusion with sulfide species.</li> <li>The as-close-as-possible MATLAB clone in <code>PyCO2SYS.original</code> no longer produces a dict but just the original <code>DATA</code>, <code>HEADERS</code> and <code>NICEHEADERS</code> outputs.</li> </ul> <p>Miscellaneous</p> <ul> <li>Documentation substantially expanded and switched to using Material for MkDocs.<ul> <li>Validation section added with internal consistency checks and an external comparison of PyCO2SYS calculations with CO2SYS for MATLAB.</li> </ul> </li> <li>All code now formatted with Black (except for module <code>original</code>).</li> <li>Version number now reported with <code>PyCO2SYS.say_hello()</code> in homage to the original MS-DOS program.</li> </ul>"},{"location":"versions/#12","title":"1.2","text":"<p>Calculates a wider variety of chemical buffer factors.</p>"},{"location":"versions/#121-9-april-2020","title":"1.2.1 (9 April 2020)","text":"<p>Changes in v1.2.1</p> <ul> <li>Fixed typo in ESM10 equations that had been carried through into <code>extra.buffers_ESM10</code> function (thanks Jim Orr!).</li> </ul>"},{"location":"versions/#120-8-april-2020","title":"1.2.0 (8 April 2020)","text":"<p>Changes in v1.2.0</p> <ul> <li>Added module <code>extra</code> containing functions to calculate variables not included in CO2SYS for MATLAB:</li> <li><code>buffers_ESM10</code> calculates the buffer factors of ESM10, corrected for the typos noted by RAH18.</li> <li><code>bgc_isocap</code> calculates the \"exact\" isocapnic quotient of HDW18, Eq. 8.</li> <li><code>bgc_isocap_approx</code> calculates the approximate isocapnic quotient of HDW18, Eq. 7.</li> <li><code>psi</code> calculates the \\psi factor of FCG94.</li> <li>Added all functions in <code>extra</code> to the <code>CO2dict</code> output of the main <code>CO2SYS</code> function, and documented in the Github repo README.</li> </ul>"},{"location":"versions/#11","title":"1.1","text":"<p>Adds optional inputs of total ammonium, hydrogen sulfide, and carbonate ion molinities for consistency with forthcoming MATLAB \"v1.21\".</p>"},{"location":"versions/#111-20-march-2020","title":"1.1.1 (20 March 2020)","text":"<p>Changes in v1.1.1</p> <ul> <li>Removed unnecessary <code>WhoseTB</code> input to <code>assemble.equilibria</code>.</li> </ul>"},{"location":"versions/#110-19-march-2020","title":"1.1.0 (19 March 2020)","text":"<p>Changes in v1.1.0</p> <ul> <li>Updated pH-solving iterative functions so that iteration stops separately for each row once it reaches the tolerance threshold.</li> <li>Extracted all functions for solving the CO<sub>2</sub> system into a separate module (<code>solve</code>).</li> <li>Extracted other key subfunctions into module <code>assemble</code>.</li> <li>Added total ammonium (<code>NH3</code>) and hydrogen sulfide (<code>H2S</code>) concentrations as optional inputs to be included in the alkalinity model.</li> <li>Added optional input to choose between different equations for hydrogen fluoride dissociation constant (<code>KFCONSTANT</code>).</li> <li>Added functions to enable carbonate ion as an input carbonate system variable.</li> <li>Output is now only the <code>CO2dict</code> dict, not the original <code>DATA</code>, <code>HEADERS</code> and <code>NICEHEADERS</code>.</li> <li>Eliminated all global variables throughout the entire program.</li> </ul>"},{"location":"versions/#10","title":"1.0","text":""},{"location":"versions/#101-28-february-2020","title":"1.0.1 (28 February 2020)","text":"<p>Starts to make things more Pythonic.</p> <p>Changes in v1.0.1</p> <ul> <li>Extracted all equations for concentrations and equilibrium constants into functions in separate modules (<code>concentrations</code> and <code>equilibria</code>).</li> <li>Eliminated all global variables from the <code>_Constants</code> function.</li> <li>Moved the as-close-as-possible version into module <code>original</code>. The default <code>from PyCO2SYS import CO2SYS</code> now imports the more Pythonic implementation.</li> </ul>"},{"location":"versions/#100-3-february-2020","title":"1.0.0 (3 February 2020)","text":"<p>An as-close-as-possible clone of MATLAB CO2SYS v2.0.5.</p> <p>Release notes for v1.0.0</p> <ul> <li>The first output <code>DICT</code> is new: a dict containing a separate entry for each variable in the original output <code>DATA</code>, with the keys named following the original output <code>HEADERS</code>.</li> <li>The output <code>DATA</code> is transposed relative to the MATLAB version because Numpy is row-major while MATLAB is column-major.</li> <li>Every combination of input options was tested against the MATLAB version with no significant differences (i.e. all differences can be attributed to floating point errors).</li> </ul>"}]}